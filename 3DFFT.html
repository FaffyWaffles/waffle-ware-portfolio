<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Audio Visualizer - Waffle Ware</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
    </style>
</head>
<body>
    <div id="react-root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo } = React;
        const { createRoot } = ReactDOM;

        // Audio Analyzer Hook
        function useAudioAnalyzer(audioRef) {
          const [frequencyData, setFrequencyData] = useState([]);
          const analyzerRef = useRef(null);
          const audioContextRef = useRef(null);
          const sourceRef = useRef(null);
          const animationRef = useRef(null);
          
          useEffect(() => {
            if (!audioRef.current) return;
            
            const setupAudio = () => {
              audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
              const audioContext = audioContextRef.current;
              
              analyzerRef.current = audioContext.createAnalyser();
              analyzerRef.current.fftSize = 2048;
              analyzerRef.current.smoothingTimeConstant = 0.8;
              
              if (!sourceRef.current) {
                sourceRef.current = audioContext.createMediaElementSource(audioRef.current);
                sourceRef.current.connect(analyzerRef.current);
                analyzerRef.current.connect(audioContext.destination);
              }
            };
            
            const analyze = () => {
              if (!analyzerRef.current) return;
              
              const bufferLength = analyzerRef.current.frequencyBinCount;
              const dataArray = new Uint8Array(bufferLength);
              analyzerRef.current.getByteFrequencyData(dataArray);
              
              const normalizedData = Array.from(dataArray).map(value => value / 255);
              const maxValue = Math.max(...normalizedData);
              
              if (maxValue > 0.01) { // Only log when there's actual audio
                console.log('Audio detected - max amplitude:', maxValue);
              }
              
              setFrequencyData(normalizedData);
              
              animationRef.current = requestAnimationFrame(analyze);
            };
            
            const handlePlay = () => {
              if (!audioContextRef.current) setupAudio();
              if (audioContextRef.current.state === 'suspended') {
                audioContextRef.current.resume();
              }
              analyze();
            };
            
            const handlePause = () => {
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            };
            
            audioRef.current.addEventListener('play', handlePlay);
            audioRef.current.addEventListener('pause', handlePause);
            
            return () => {
              if (audioRef.current) {
                audioRef.current.removeEventListener('play', handlePlay);
                audioRef.current.removeEventListener('pause', handlePause);
              }
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            };
          }, [audioRef]);
          
          return frequencyData;
        }

        // Visualization styles
        const STYLES = {
          STANDARD: 'standard',
          CORNER: 'corner',
          CENTER: 'center',
          RANDOM: 'random'
        };

        // Visualization modes
        const MODES = {
          POINTS: 'points',
          NURBS: 'nurbs'
        };

        // Points Visualizer
        function PointsVisualizer({ frequencyData, samples, style, mountRef }) {
          const sceneRef = useRef(null);
          const rendererRef = useRef(null);
          const cameraRef = useRef(null);
          const meshesRef = useRef([]);
          const frameRef = useRef(null);
          const rotationRef = useRef({ x: 0, y: 0 });
          
          useEffect(() => {
            console.log('PointsVisualizer effect triggered, mountRef.current:', mountRef.current);
            
            // Use a timeout to ensure the DOM is ready
            const initScene = () => {
              if (!mountRef.current) {
                console.log('No mountRef.current, retrying...');
                setTimeout(initScene, 10);
                return;
              }
              
              console.log('Initializing Three.js scene');
              
              const width = mountRef.current.clientWidth;
              const height = mountRef.current.clientHeight;
              
              console.log('Canvas dimensions:', width, 'x', height);
            
            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            sceneRef.current = scene;
            
            // Camera
            const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 1, 2); // Moved camera back and up
            camera.lookAt(0, 0, 0);
            cameraRef.current = camera;
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            mountRef.current.appendChild(renderer.domElement);
            rendererRef.current = renderer;
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // Create grid of cubes
            const gridSize = Math.floor(Math.sqrt(samples));
            const geometry = new THREE.BoxGeometry(0.05, 0.05, 0.05); // Made cubes bigger
            const meshes = [];
            
            console.log('Creating grid with size:', gridSize, 'total cubes:', gridSize * gridSize);
            
            // Generate positions based on style
            const positions = [];
            const offset = -0.5;
            
            for (let i = 0; i < gridSize; i++) {
              for (let j = 0; j < gridSize; j++) {
                const x = (i / (gridSize - 1)) + offset;
                const z = (j / (gridSize - 1)) + offset;
                positions.push({ x, y: 0, z, index: i * gridSize + j });
              }
            }
            
            // Apply style sorting
            if (style === STYLES.CORNER) {
              positions.sort((a, b) => {
                const distA = Math.abs(a.x) + Math.abs(a.z);
                const distB = Math.abs(b.x) + Math.abs(b.z);
                return distA - distB;
              });
            } else if (style === STYLES.CENTER) {
              positions.sort((a, b) => {
                const distA = Math.sqrt(a.x ** 2 + a.z ** 2);
                const distB = Math.sqrt(b.x ** 2 + b.z ** 2);
                return distA - distB;
              });
            } else if (style === STYLES.RANDOM) {
              for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
              }
            }
            
            // Create meshes
            positions.forEach((pos, i) => {
              const material = new THREE.MeshStandardMaterial({ 
                color: 0x00bfff,
                emissive: 0x001122 // Add some glow
              });
              const mesh = new THREE.Mesh(geometry, material);
              mesh.position.set(pos.x, pos.y, pos.z);
              mesh.userData = { baseY: pos.y, index: i };
              scene.add(mesh);
              meshes.push(mesh);
            });
            
            console.log('Created', meshes.length, 'cubes');
            
            meshesRef.current = meshes;
            
            // Mouse controls
            let isMouseDown = false;
            const startMouse = { x: 0, y: 0 };
            const startRotation = { x: 0, y: 0 };
            
            const handleMouseDown = (event) => {
              isMouseDown = true;
              startMouse.x = event.clientX;
              startMouse.y = event.clientY;
              startRotation.x = rotationRef.current.x;
              startRotation.y = rotationRef.current.y;
              mountRef.current.style.cursor = 'grabbing';
            };
            
            const handleMouseMove = (event) => {
              if (!isMouseDown) return;
              
              const deltaX = (event.clientX - startMouse.x) / width;
              const deltaY = (event.clientY - startMouse.y) / height;
              
              rotationRef.current.y = startRotation.y + deltaX * 2;
              rotationRef.current.x = startRotation.x + deltaY * 2;
            };
            
            const handleMouseUp = () => {
              isMouseDown = false;
              mountRef.current.style.cursor = 'grab';
            };
            
            mountRef.current.style.cursor = 'grab';
            mountRef.current.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            
            // Handle resize
            const handleResize = () => {
              const width = mountRef.current.clientWidth;
              const height = mountRef.current.clientHeight;
              
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
              renderer.setSize(width, height);
            };
            
            window.addEventListener('resize', handleResize);
            
            // Animation loop
            const animate = () => {
              frameRef.current = requestAnimationFrame(animate);
              
              // Rotate camera
              const radius = 2.5;
              camera.position.x = Math.sin(rotationRef.current.y) * radius;
              camera.position.y = 1 + rotationRef.current.x * 0.5;
              camera.position.z = Math.cos(rotationRef.current.y) * radius;
              camera.lookAt(0, 0, 0);
              
              // Update cube positions and colors based on frequency data
              if (frequencyData.length > 0) {
                const maxFreq = Math.max(...frequencyData);
                if (maxFreq > 0.1) { // Only log when there's significant audio
                  console.log('Animating cubes with freq data:', frequencyData.length, 'samples, max:', maxFreq);
                }
              }
              
              meshesRef.current.forEach((mesh, i) => {
                const dataIndex = Math.floor((i / meshesRef.current.length) * frequencyData.length);
                const amplitude = frequencyData[dataIndex] || 0;
                
                // Smooth position update
                const targetY = mesh.userData.baseY + amplitude * 2; // Increased multiplier
                mesh.position.y += (targetY - mesh.position.y) * 0.2; // Faster response
                
                // Update color based on amplitude
                const hue = amplitude * 0.7;
                mesh.material.color.setHSL(hue, 1, 0.5);
              });
              
              renderer.render(scene, camera);
            };
            
            animate();
            
            // Cleanup
            return () => {
              mountRef.current?.removeEventListener('mousedown', handleMouseDown);
              window.removeEventListener('mousemove', handleMouseMove);
              window.removeEventListener('mouseup', handleMouseUp);
              window.removeEventListener('resize', handleResize);
              
              if (frameRef.current) {
                cancelAnimationFrame(frameRef.current);
              }
              
              meshesRef.current.forEach(mesh => {
                mesh.geometry.dispose();
                mesh.material.dispose();
              });
              
              renderer.dispose();
              if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
              }
            };
            }; // Close initScene function
            
            initScene(); // Call initScene
          }, [samples, style]);
          
          return null;
        }

        // Main 3D Visualizer Component
        function ThreeVisualizer({ frequencyData, samples, style, mode }) {
          const mountRef = useRef(null);
          
          useEffect(() => {
            console.log('ThreeVisualizer mounted, mountRef:', mountRef.current);
          }, []);
          
          return React.createElement('div', { 
            ref: mountRef, 
            className: "w-full h-full"
          }, React.createElement(PointsVisualizer, {
            frequencyData: frequencyData,
            samples: samples,
            style: style,
            mountRef: mountRef
          }));
        }

        // Main App Component
        function AudioVisualizer3D() {
          const audioRef = useRef(null);
          const fileInputRef = useRef(null);
          const [samples, setSamples] = useState(1024);
          const [style, setStyle] = useState(STYLES.STANDARD);
          const [mode, setMode] = useState(MODES.POINTS);
          const [isPlaying, setIsPlaying] = useState(false);
          const [currentFile, setCurrentFile] = useState(null);
          
          const frequencyData = useAudioAnalyzer(audioRef);
          
          const handleFileUpload = (e) => {
            const file = e.target.files[0];
            if (file && audioRef.current) {
              const url = URL.createObjectURL(file);
              audioRef.current.src = url;
              setCurrentFile(file.name);
              setIsPlaying(false);
            }
          };
          
          const togglePlayPause = () => {
            if (audioRef.current && audioRef.current.src) {
              if (isPlaying) {
                audioRef.current.pause();
              } else {
                audioRef.current.play().catch(err => {
                  console.error('Error playing audio:', err);
                });
              }
            }
          };
          
          
          // Ensure samples is power of 2
          const validSamples = useMemo(() => {
            const powers = [64, 256, 1024, 4096];
            return powers.reduce((prev, curr) => 
              Math.abs(curr - samples) < Math.abs(prev - samples) ? curr : prev
            );
          }, [samples]);
          
          return React.createElement('div', {
            className: "w-full h-screen bg-black flex flex-col"
          }, [
            // Controls
            React.createElement('div', {
              key: 'controls',
              className: "bg-gray-900 p-4 flex gap-4 items-center text-white"
            }, [
              React.createElement('input', {
                key: 'file-input',
                ref: fileInputRef,
                type: 'file',
                accept: 'audio/*',
                onChange: handleFileUpload,
                className: 'hidden'
              }),
              React.createElement('button', {
                key: 'load-button',
                onClick: () => fileInputRef.current?.click(),
                className: "px-4 py-2 bg-blue-600 rounded hover:bg-blue-700 transition-colors"
              }, 'Load Audio'),
              React.createElement('button', {
                key: 'play-button',
                onClick: togglePlayPause,
                className: `px-4 py-2 rounded transition-colors ${
                  audioRef.current?.src 
                    ? 'bg-green-600 hover:bg-green-700 cursor-pointer' 
                    : 'bg-gray-600 cursor-not-allowed opacity-50'
                }`,
                disabled: !audioRef.current?.src
              }, isPlaying ? 'Pause' : 'Play'),
              React.createElement('select', {
                key: 'style-select',
                value: style,
                onChange: (e) => setStyle(e.target.value),
                className: "px-4 py-2 bg-gray-800 rounded text-white"
              }, [
                React.createElement('option', { key: 'standard', value: STYLES.STANDARD }, 'Standard'),
                React.createElement('option', { key: 'corner', value: STYLES.CORNER }, 'Corner'),
                React.createElement('option', { key: 'center', value: STYLES.CENTER }, 'Center'),
                React.createElement('option', { key: 'random', value: STYLES.RANDOM }, 'Random')
              ]),
              React.createElement('label', {
                key: 'samples-label',
                className: "flex items-center gap-2"
              }, [
                'Samples:',
                React.createElement('select', {
                  key: 'samples-select',
                  value: validSamples,
                  onChange: (e) => setSamples(Number(e.target.value)),
                  className: "px-2 py-1 bg-gray-800 rounded text-white"
                }, [
                  React.createElement('option', { key: '64', value: 64 }, '64'),
                  React.createElement('option', { key: '256', value: 256 }, '256'),
                  React.createElement('option', { key: '1024', value: 1024 }, '1024'),
                  React.createElement('option', { key: '4096', value: 4096 }, '4096')
                ])
              ]),
              currentFile && React.createElement('div', {
                key: 'current-file',
                className: "text-sm text-gray-300 bg-gray-800 px-3 py-2 rounded"
              }, `Current: ${currentFile}`),
              React.createElement('div', {
                key: 'help-text',
                className: "ml-auto text-sm text-gray-400"
              }, 'Click and drag to rotate view')
            ]),
            // 3D Canvas
            React.createElement('div', {
              key: 'canvas',
              className: "flex-1"
            }, React.createElement(ThreeVisualizer, {
              frequencyData: frequencyData,
              samples: validSamples,
              style: style,
              mode: mode
            })),
            // Hidden audio element
            React.createElement('audio', {
              key: 'audio',
              ref: audioRef,
              onPlay: () => setIsPlaying(true),
              onPause: () => setIsPlaying(false)
            })
          ]);
        }

        const root = createRoot(document.getElementById('react-root'));
        root.render(React.createElement(AudioVisualizer3D));
    </script>
</body>
</html>