<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Types Hasse Diagram - Waffle Ware</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            color: rgba(255,255,255,0.9);
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        
        .back-link {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .back-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #diagram {
            width: 100%;
            height: 700px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #fafafa;
        }
        
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2;
            transition: all 0.2s ease;
        }
        
        .links line:hover {
            stroke: #333;
            stroke-width: 3;
            stroke-opacity: 0.8;
        }
        
        .links line.highlighted {
            stroke: #ff6b6b;
            stroke-width: 4;
            stroke-opacity: 1;
        }
        
        .nodes circle {
            stroke: #333;
            stroke-width: 2;
            cursor: grab;
        }
        
        .nodes circle:active {
            cursor: grabbing;
        }
        
        .nodes text {
            font-size: 11px;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            font-weight: 600;
            fill: black;
        }
        
        .highlighted {
            stroke: #ff6b6b !important;
            stroke-width: 4 !important;
        }
        
        .highlighted-node {
            stroke: #ff6b6b !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 10px rgba(255,107,107,0.5));
        }
        
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .legend-item {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        
        .legend-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .description {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            line-height: 1.6;
        }
        
        .description h3 {
            color: #333;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üßá Matrix Types Hasse Diagram</h1>
        <p>Interactive exploration of matrix classification hierarchies</p>
        <a href="index.html" class="back-link">‚Üê Back to Portfolio</a>
    </div>
    
    <div class="container">
        <div class="controls">
            <button onclick="restartSimulation()">Reset Layout</button>
            <button onclick="toggleAnimation()">Toggle Animation</button>
            <button onclick="showOnlyConnections()">Show Only Direct Connections</button>
            <button onclick="highlightPath('Identity')">Path to Identity</button>
            <button onclick="highlightPath('Orthogonal')">Path to Orthogonal</button>
            <button onclick="highlightPath('Symmetric')">Path to Symmetric</button>
        </div>
        
        <svg id="diagram"></svg>
        
        <div class="legend">
            <div class="legend-item">
                <span class="legend-color" style="background: #ffeb3b;"></span>
                <span>General Categories</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #4caf50;"></span>
                <span>Definite Matrices</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #2196f3;"></span>
                <span>Special Structures</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #9c27b0;"></span>
                <span>Triangular Types</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #ff5722;"></span>
                <span>Diagonal Dominant</span>
            </div>
        </div>
        
        <div class="description">
            <h3>About This Visualization</h3>
            <p>
                This interactive Hasse diagram represents the hierarchical relationships between different types of matrices in linear algebra. 
                Each node represents a matrix classification, and the connections show subset relationships - if matrix type A connects to 
                matrix type B above it, then all matrices of type A are also matrices of type B.
            </p>
            <p>
                <strong>Visual Clarity:</strong> The layout uses strong repulsion forces to prevent lines from overlapping through unconnected nodes. 
                When you hover over a node, only its direct connections are highlighted while other elements fade, making relationships crystal clear.
            </p>
            <p>
                <strong>How to use:</strong> Hover over nodes to see immediate relationships, use "Show Only Direct Connections" to focus on 
                individual node relationships, trace specific inheritance chains with the path buttons, or drag nodes around to explore. 
                The stronger spacing prevents visual confusion from overlapping connection lines.
            </p>
        </div>
    </div>

    <script>
        // Define the matrix hierarchy data
        const matrixHierarchy = {
            "Rectangular": {
                color: "#ffeb3b",
                children: {
                    "Square": {
                        color: "#ffeb3b",
                        children: {
                            "Normal": {
                                color: "#ffeb3b",
                                children: {
                                    "Symmetric": {
                                        color: "#4caf50",
                                        children: {
                                            "Diagonal": {
                                                color: "#2196f3",
                                                children: {
                                                    "Scalar": {
                                                        color: "#2196f3",
                                                        children: {
                                                            "Identity": { color: "#2196f3" },
                                                            "Zero": { color: "#333" }
                                                        }
                                                    }
                                                }
                                            },
                                            "Positive Semidefinite": { color: "#4caf50" },
                                            "Orthogonal Involutory": { color: "#ff9800" }
                                        }
                                    },
                                    "Hermitian": {
                                        color: "#4caf50",
                                        children: {
                                            "Positive Definite": { color: "#4caf50" },
                                            "Negative Definite": { color: "#f44336" }
                                        }
                                    }
                                }
                            },
                            "Triangular": {
                                color: "#9c27b0",
                                children: {
                                    "Upper Triangular": { color: "#9c27b0" },
                                    "Lower Triangular": { color: "#9c27b0" }
                                }
                            },
                            "Unitary": {
                                color: "#2196f3",
                                children: {
                                    "Special Unitary": { color: "#2196f3" }
                                }
                            },
                            "Orthogonal": {
                                color: "#2196f3",
                                children: {
                                    "Special Orthogonal": {
                                        color: "#2196f3",
                                        children: {
                                            "Rotation": { color: "#2196f3" }
                                        }
                                    },
                                    "Symmetric Involutory": { color: "#ff9800" }
                                }
                            },
                            "Anti-Symmetric": {
                                color: "#333",
                                children: {
                                    "Zero": { color: "#333" }
                                }
                            },
                            "Anti-Hermitian": { color: "#333" },
                            "Involutory": {
                                color: "#ff9800",
                                children: {
                                    "Identity": { color: "#2196f3" },
                                    "Symmetric Orthogonal": { color: "#ff9800" }
                                }
                            },
                            "Shear": { color: "#795548" },
                            "Z-Matrix": {
                                color: "#9c27b0",
                                children: {
                                    "L-Matrix": {
                                        color: "#9c27b0",
                                        children: {
                                            "M-Matrix": { color: "#4caf50" }
                                        }
                                    }
                                }
                            },
                            "H-Matrix": {
                                color: "#f44336",
                                children: {
                                    "M-Matrix": { color: "#4caf50" }
                                }
                            },
                            "Weakly Diagonally Dominant": {
                                color: "#ff5722",
                                children: {
                                    "Strictly Diagonally Dominant": { color: "#ff5722" }
                                }
                            },
                            "Uniform": {
                                color: "#607d8b",
                                children: {
                                    "All-Ones": { color: "#607d8b" },
                                    "Zero": { color: "#333" }
                                }
                            },
                            "Scaled Elementary": { color: "#e91e63" },
                            "Reflection": { color: "#e91e63" },
                            "Negative Semidefinite": { color: "#f44336" }
                        }
                    },
                    "Vectors": {
                        color: "#4caf50",
                        children: {
                            "Row Matrix": { color: "#ffeb3b" },
                            "Column Matrix": { color: "#ffeb3b" }
                        }
                    }
                }
            }
        };

        // Convert hierarchy to nodes and links format (same as before)
        function hierarchyToGraph(data) {
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
            
            function traverse(obj, parent = null) {
                for (const [name, info] of Object.entries(obj)) {
                    if (!nodeMap.has(name)) {
                        const node = {
                            id: name,
                            name: name,
                            color: info.color || "#2196f3"
                        };
                        nodes.push(node);
                        nodeMap.set(name, node);
                    }
                    
                    if (parent) {
                        const linkExists = links.some(link => 
                            link.source === parent && link.target === name
                        );
                        if (!linkExists) {
                            links.push({
                                source: parent,
                                target: name
                            });
                        }
                    }
                    
                    if (info.children) {
                        traverse(info.children, name);
                    }
                }
            }
            
            traverse(data);
            return { nodes, links };
        }

        // Set up the visualization using the clean D3 pattern
        const width = 1300;
        const height = 700;

        const svg = d3.select("#diagram")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        // Create a container group for zoom
        const container = svg.append("g");

        // Generate graph data
        const { nodes, links } = hierarchyToGraph(matrixHierarchy);
        
        // Copy for simulation (prevents mutation issues)
        const graphLinks = links.map(d => ({...d}));
        const graphNodes = nodes.map(d => ({...d}));

        // Create simulation with better spacing
        const simulation = d3.forceSimulation(graphNodes)
            .force("link", d3.forceLink(graphLinks).id(d => d.id).distance(100).strength(0.7))
            .force("charge", d3.forceManyBody().strength(-800)) // Much stronger repulsion
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(35)) // Larger collision radius
            .force("x", d3.forceX(width / 2).strength(0.05)) // Gentle centering
            .force("y", d3.forceY(height / 2).strength(0.05));

        // Add links to container
        const link = container.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graphLinks)
            .join("line");

        // Add node groups to container
        const node = container.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(graphNodes)
            .join("g");

        // Add circles to nodes
        node.append("circle")
            .attr("r", 20)
            .attr("fill", d => d.color);

        // Add text to nodes
        node.append("text")
            .text(d => {
                // Truncate long names for better display
                return d.name.length > 12 ? d.name.substring(0, 10) + "..." : d.name;
            })
            .each(function(d) {
                // Handle text wrapping for longer names
                const text = d3.select(this);
                const words = d.name.split(/\s+/);
                if (words.length > 1 && d.name.length > 10) {
                    text.text('');
                    text.append('tspan')
                        .attr('x', 0)
                        .attr('dy', '-0.2em')
                        .text(words[0]);
                    text.append('tspan')
                        .attr('x', 0)
                        .attr('dy', '1.2em')
                        .text(words.slice(1).join(' ').substring(0, 8));
                }
            });

        // Add tooltips
        node.append("title")
            .text(d => d.name);

        // Add hover effects with better visual feedback
        node.on("mouseover", function(event, d) {
            // Highlight the hovered node
            d3.select(this).select("circle").classed("highlighted-node", true);
            
            if (showingConnectionsOnly) {
                // In connection-only mode, show only direct connections
                link.style("opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.05);
                node.select("circle").style("opacity", n => {
                    if (n.id === d.id) return 1;
                    const isConnected = graphLinks.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) || 
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return isConnected ? 1 : 0.1;
                });
                node.select("text").style("opacity", n => {
                    if (n.id === d.id) return 1;
                    const isConnected = graphLinks.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) || 
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return isConnected ? 1 : 0.1;
                });
            } else {
                // Normal mode
                link.classed("highlighted", l => l.source.id === d.id || l.target.id === d.id)
                    .style("opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.2);
                
                node.select("circle").style("opacity", n => {
                    if (n.id === d.id) return 1;
                    const isConnected = graphLinks.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) || 
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return isConnected ? 1 : 0.4;
                });
            }
        })
        .on("mouseout", function(event, d) {
            if (!showingConnectionsOnly) {
                // Reset styling in normal mode
                d3.select(this).select("circle").classed("highlighted-node", false);
                link.classed("highlighted", false).style("opacity", 1);
                node.select("circle").style("opacity", 1);
            } else {
                // In connection-only mode, return to faded state
                d3.select(this).select("circle").classed("highlighted-node", false);
                link.style("opacity", 0.1);
                node.select("circle").style("opacity", 0.3);
                node.select("text").style("opacity", 0.3);
            }
        });

        // Add drag behavior (clean D3 pattern)
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        // Tick function (clean D3 pattern)
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions (clean D3 pattern)
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        // Control functions
        let showingConnectionsOnly = false;
        
        function showOnlyConnections() {
            showingConnectionsOnly = !showingConnectionsOnly;
            
            if (showingConnectionsOnly) {
                // Make all links very faint
                link.style("opacity", 0.1);
                node.select("circle").style("opacity", 0.3);
                node.select("text").style("opacity", 0.3);
                
                // Add instruction text
                svg.append("text")
                    .attr("id", "instruction-text")
                    .attr("x", width / 2)
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .style("fill", "#333")
                    .text("Hover over nodes to see their direct connections");
                    
                document.querySelector('button[onclick="showOnlyConnections()"]').textContent = "Show All";
            } else {
                // Reset to normal view
                link.style("opacity", 1);
                node.select("circle").style("opacity", 1);
                node.select("text").style("opacity", 1);
                svg.select("#instruction-text").remove();
                document.querySelector('button[onclick="showOnlyConnections()"]').textContent = "Show Only Direct Connections";
            }
        }

        function restartSimulation() {
            // Reset all fixed positions
            graphNodes.forEach(d => {
                d.fx = null;
                d.fy = null;
            });
            // Clear highlights and reset view
            node.select("circle").classed("highlighted-node", false).style("opacity", 1);
            link.classed("highlighted", false).style("opacity", 1);
            node.select("text").style("opacity", 1);
            svg.select("#instruction-text").remove();
            showingConnectionsOnly = false;
            document.querySelector('button[onclick="showOnlyConnections()"]').textContent = "Show Only Direct Connections";
            // Restart simulation
            simulation.alpha(1).restart();
        }

        let animationRunning = true;
        function toggleAnimation() {
            if (animationRunning) {
                simulation.stop();
                animationRunning = false;
            } else {
                simulation.restart();
                animationRunning = true;
            }
        }

        function highlightPath(targetName) {
            // Clear previous highlights
            node.select("circle").classed("highlighted-node", false);
            link.classed("highlighted", false);
            
            // Find path from root to target
            function findPath(target) {
                const path = [];
                const visited = new Set();
                
                function dfs(current, currentPath) {
                    if (visited.has(current)) return false;
                    visited.add(current);
                    currentPath.push(current);
                    
                    if (current === target) {
                        path.push(...currentPath);
                        return true;
                    }
                    
                    for (const link of graphLinks) {
                        if (link.source.id === current && dfs(link.target.id, [...currentPath])) {
                            return true;
                        }
                    }
                    
                    return false;
                }
                
                dfs("Rectangular", []);
                return path;
            }
            
            const path = findPath(targetName);
            
            // Highlight path nodes
            node.select("circle").classed("highlighted-node", d => path.includes(d.id));
            
            // Highlight path links
            link.classed("highlighted", l => {
                const sourceIndex = path.indexOf(l.source.id);
                const targetIndex = path.indexOf(l.target.id);
                return sourceIndex !== -1 && targetIndex !== -1 && Math.abs(sourceIndex - targetIndex) === 1;
            });
        }

        // Add zoom functionality
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", function(event) {
                container.attr("transform", event.transform);
            });
        
        svg.call(zoom);
    </script>
</body>
</html>