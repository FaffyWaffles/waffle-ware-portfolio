<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Types Hasse Diagram - Waffle Ware</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            color: rgba(255,255,255,0.9);
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        
        .back-link {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .back-link:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #diagram {
            width: 100%;
            height: 700px;
            border: 2px solid #ddd;
            border-radius: 10px;
            background: #fafafa;
        }
        
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2;
            transition: all 0.2s ease;
        }
        
        .links line:hover {
            stroke: #333;
            stroke-width: 3;
            stroke-opacity: 0.8;
        }
        
        .links line.highlighted {
            stroke: #ff6b6b;
            stroke-width: 4;
            stroke-opacity: 1;
        }
        
        .nodes circle {
            stroke: #333;
            stroke-width: 2;
            cursor: grab;
        }
        
        .nodes circle:active {
            cursor: grabbing;
        }
        
        .nodes circle.multiple-parents {
            stroke: #ff6b6b;
            stroke-width: 3;
            stroke-dasharray: 3,3;
        }
        
        .nodes circle.special-equivalence {
            stroke: #ff6b6b;
            stroke-width: 4;
            stroke-dasharray: 5,5;
            animation: pulse 2s ease-in-out infinite alternate;
        }
        
        @keyframes pulse {
            from { stroke-opacity: 0.5; }
            to { stroke-opacity: 1; }
        }
        
        .nodes text.special-text {
            font-weight: bold;
            font-size: 10px;
        }
        
        .nodes text.multiple-parents-text {
            font-weight: 600;
        }
        
        .nodes circle:active {
            cursor: grabbing;
        }
        
        .nodes text {
            font-size: 11px;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            font-weight: 600;
            fill: black;
        }
        
        .highlighted {
            stroke: #ff6b6b !important;
            stroke-width: 4 !important;
        }
        
        .highlighted-node {
            stroke: #ff6b6b !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 10px rgba(255,107,107,0.5));
        }
        
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .legend-item {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        
        .legend-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .description {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            line-height: 1.6;
        }
        
        .description h3 {
            color: #333;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üßá Matrix Types Hasse Diagram</h1>
        <p>Interactive exploration of matrix classification hierarchies</p>
        <a href="index.html" class="back-link">‚Üê Back to Portfolio</a>
    </div>
    
    <div class="container">
        <div class="controls">
            <button onclick="restartSimulation()">Reset Layout</button>
            <button onclick="toggleAnimation()">Toggle Animation</button>
            <button onclick="showOnlyConnections()">Show Only Direct Connections</button>
            <button onclick="highlightMultipleInheritance()">Highlight Multiple Inheritance</button>
            <button onclick="highlightNormalMatrices()">Highlight Normal Structure</button>
            <button onclick="highlightPath('Identity')">Path to Identity</button>
            <button onclick="highlightPath('Diagonal')">Path to Diagonal</button>
        </div>
        
        <svg id="diagram"></svg>
        
        <div class="legend">
            <div class="legend-item">
                <span class="legend-color" style="background: #ffeb3b;"></span>
                <span>General Categories</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #4caf50;"></span>
                <span>Definite Matrices</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #2196f3;"></span>
                <span>Special Structures</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #9c27b0;"></span>
                <span>Triangular Types</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: #ff5722;"></span>
                <span>Diagonal Dominant</span>
            </div>
        </div>
        
        <div class="description">
            <h3>Mathematically Accurate Matrix Classification Hasse Diagram</h3>
            <p>
                This interactive Hasse diagram represents the true hierarchical relationships between matrix types as a 
                <strong>Directed Acyclic Graph (DAG)</strong> rather than a simple tree. Each node represents a matrix classification, 
                and edges show subset relationships with <strong>multiple inheritance</strong> where mathematically appropriate.
            </p>
            <p>
                <strong>Key Mathematical Corrections:</strong> 
                ‚Ä¢ Unitary and Orthogonal matrices are properly shown as Normal (AA* = A*A) 
                ‚Ä¢ Diagonal matrices have multiple parents: Symmetric ‚à© Upper Triangular ‚à© Lower Triangular
                ‚Ä¢ Definite matrices are correctly placed only under Hermitian 
                ‚Ä¢ Skew-Symmetric and Skew-Hermitian are Normal 
                ‚Ä¢ Reflection matrices are Orthogonal ‚à© Involutory 
                ‚Ä¢ Shear matrices are Upper Triangular
            </p>
            <p>
                <strong>Visual Indicators:</strong> Nodes with dashed borders have multiple inheritance (satisfy multiple independent conditions). 
                The special three-way equivalence node shows where Symmetric ‚à© Orthogonal ‚â° Involutory. This DAG structure 
                accurately represents the mathematical lattice of matrix properties.
            </p>
            <p>
                <strong>How to use:</strong> Hover over nodes to see direct connections, use "Highlight Multiple Inheritance" to see 
                nodes with multiple parents, "Highlight Normal Structure" shows the key role of normal matrices, or trace 
                inheritance paths to see the rich mathematical relationships.
            </p>
        </div>
    </div>

    <script>
        // Define the matrix types with multiple parents (DAG structure)
        const matrixTypes = {
            "Rectangular": { color: "#ffeb3b", parents: [] },
            "Square": { color: "#ffeb3b", parents: ["Rectangular"] },
            "Vectors": { color: "#4caf50", parents: ["Rectangular"] },
            "Row Matrix": { color: "#ffeb3b", parents: ["Vectors"] },
            "Column Matrix": { color: "#ffeb3b", parents: ["Vectors"] },
            
            // Normal matrices - key structural position
            "Normal": { color: "#e8f5e8", parents: ["Square"] },
            
            // Under Normal: Symmetric & Hermitian
            "Symmetric": { color: "#4caf50", parents: ["Normal"] },
            "Hermitian": { color: "#4caf50", parents: ["Normal"] },
            
            // Under Normal: Unitary & Orthogonal (FIXED)
            "Unitary": { color: "#2196f3", parents: ["Normal"] },
            "Orthogonal": { color: "#2196f3", parents: ["Normal"] },
            "Special Unitary": { color: "#2196f3", parents: ["Unitary"] },
            "Special Orthogonal": { color: "#2196f3", parents: ["Orthogonal"] },
            "Rotation": { color: "#2196f3", parents: ["Special Orthogonal"] },
            
            // Under Normal: Skew matrices (FIXED)
            "Skew-Symmetric": { color: "#333", parents: ["Normal"] },
            "Skew-Hermitian": { color: "#333", parents: ["Normal"] },
            
            // Involutory matrices
            "Involutory": { color: "#ff9800", parents: ["Square"] },
            
            // Triangular matrices
            "Triangular": { color: "#9c27b0", parents: ["Square"] },
            "Upper Triangular": { color: "#9c27b0", parents: ["Triangular"] },
            "Lower Triangular": { color: "#9c27b0", parents: ["Triangular"] },
            
            // Diagonal matrices - multiple parents (FIXED)
            "Diagonal": { color: "#2196f3", parents: ["Symmetric", "Upper Triangular", "Lower Triangular"] },
            "Scalar": { color: "#2196f3", parents: ["Diagonal"] },
            "Identity": { color: "#2196f3", parents: ["Scalar"] },
            "Zero": { color: "#333", parents: ["Scalar", "Skew-Symmetric"] },
            
            // Definite matrices - only under Hermitian (FIXED)
            "Positive Definite": { color: "#4caf50", parents: ["Hermitian"] },
            "Positive Semidefinite": { color: "#4caf50", parents: ["Hermitian"] },
            "Negative Definite": { color: "#f44336", parents: ["Hermitian"] },
            "Negative Semidefinite": { color: "#f44336", parents: ["Hermitian"] },
            
            // Shear matrices - under triangular (FIXED)
            "Shear": { color: "#795548", parents: ["Upper Triangular"] },
            
            // Reflection matrices - multiple parents (FIXED)
            "Reflection": { color: "#e91e63", parents: ["Orthogonal", "Involutory"] },
            
            // Special three-way equivalence
            "Symmetric-Orthogonal-Involutory": { 
                color: "#ff9800", 
                parents: ["Symmetric", "Orthogonal", "Involutory"],
                special: true 
            },
            
            // Matrix families
            "Z-Matrix": { color: "#9c27b0", parents: ["Square"] },
            "L-Matrix": { color: "#9c27b0", parents: ["Z-Matrix"] },
            "M-Matrix": { color: "#4caf50", parents: ["L-Matrix", "H-Matrix"] },
            "H-Matrix": { color: "#f44336", parents: ["Square"] },
            
            // Diagonally dominant
            "Weakly Diagonally Dominant": { color: "#ff5722", parents: ["Square"] },
            "Strictly Diagonally Dominant": { color: "#ff5722", parents: ["Weakly Diagonally Dominant"] },
            
            // Uniform matrices
            "Uniform": { color: "#607d8b", parents: ["Square"] },
            "All-Ones": { color: "#607d8b", parents: ["Uniform"] },
            
            // Elementary matrices  
            "Scaled Elementary": { color: "#e91e63", parents: ["Square"] }
        };

        // Convert DAG structure to nodes and links
        function dagToGraph(matrixTypes) {
            const nodes = [];
            const links = [];
            
            // Create nodes
            for (const [name, info] of Object.entries(matrixTypes)) {
                nodes.push({
                    id: name,
                    name: name,
                    color: info.color,
                    special: info.special || false,
                    parents: info.parents || []
                });
            }
            
            // Create links from parent relationships
            for (const [childName, info] of Object.entries(matrixTypes)) {
                for (const parentName of info.parents) {
                    links.push({
                        source: parentName,
                        target: childName
                    });
                }
            }
            
            return { nodes, links };
        }

        // Set up the visualization using the clean D3 pattern
        const width = 1300;
        const height = 700;

        const svg = d3.select("#diagram")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height]);

        // Create a container group for zoom
        const container = svg.append("g");

        // Generate graph data from DAG structure
        const { nodes, links } = dagToGraph(matrixTypes);
        
        // Copy for simulation (prevents mutation issues)
        const graphLinks = links.map(d => ({...d}));
        const graphNodes = nodes.map(d => ({...d}));

        // Create simulation with better spacing
        const simulation = d3.forceSimulation(graphNodes)
            .force("link", d3.forceLink(graphLinks).id(d => d.id).distance(100).strength(0.7))
            .force("charge", d3.forceManyBody().strength(-800)) // Much stronger repulsion
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(35)) // Larger collision radius
            .force("x", d3.forceX(width / 2).strength(0.05)) // Gentle centering
            .force("y", d3.forceY(height / 2).strength(0.05));

        // Add links to container
        const link = container.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(graphLinks)
            .join("line");

        // Add node groups to container
        const node = container.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(graphNodes)
            .join("g");

        // Add circles to nodes with proper styling
        node.append("circle")
            .attr("r", 20)
            .attr("fill", d => d.color)
            .classed("special-equivalence", d => d.special)
            .classed("multiple-parents", d => d.parents.length > 1 && !d.special);

        // Add text to nodes with improved labeling
        node.append("text")
            .classed("special-text", d => d.special)
            .classed("multiple-parents-text", d => d.parents.length > 1)
            .text(d => {
                // Special handling for the three-way equivalence node
                if (d.special) {
                    return "Sym‚äïOrth‚äïInv";
                }
                // Shortened names for better display
                const shortNames = {
                    "Symmetric-Orthogonal-Involutory": "Sym‚äïOrth‚äïInv",
                    "Upper Triangular": "Upper Tri",
                    "Lower Triangular": "Lower Tri", 
                    "Positive Definite": "Pos Def",
                    "Negative Definite": "Neg Def",
                    "Positive Semidefinite": "Pos SemiDef",
                    "Negative Semidefinite": "Neg SemiDef",
                    "Skew-Symmetric": "Skew-Sym",
                    "Skew-Hermitian": "Skew-Herm",
                    "Special Unitary": "Sp Unitary",
                    "Special Orthogonal": "Sp Orthog",
                    "Strictly Diagonally Dominant": "Strict DiagDom",
                    "Weakly Diagonally Dominant": "Weak DiagDom",
                    "Scaled Elementary": "Scaled Elem"
                };
                
                return shortNames[d.name] || (d.name.length > 12 ? d.name.substring(0, 10) + "..." : d.name);
            })
            .each(function(d) {
                // Handle text wrapping for longer names (but not for special nodes)
                if (!d.special && !d.name.includes("Triangular")) {
                    const text = d3.select(this);
                    const words = d.name.split(/\s+/);
                    if (words.length > 1 && d.name.length > 10) {
                        text.text('');
                        text.append('tspan')
                            .attr('x', 0)
                            .attr('dy', '-0.2em')
                            .text(words[0]);
                        text.append('tspan')
                            .attr('x', 0)
                            .attr('dy', '1.2em')
                            .text(words.slice(1).join(' ').substring(0, 8));
                    }
                }
            });

        // Add tooltips
        node.append("title")
            .text(d => d.name);

        // Add hover effects with better visual feedback
        node.on("mouseover", function(event, d) {
            // Highlight the hovered node
            d3.select(this).select("circle").classed("highlighted-node", true);
            
            if (showingConnectionsOnly) {
                // In connection-only mode, show only direct connections
                link.style("opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.05);
                node.select("circle").style("opacity", n => {
                    if (n.id === d.id) return 1;
                    const isConnected = graphLinks.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) || 
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return isConnected ? 1 : 0.1;
                });
                node.select("text").style("opacity", n => {
                    if (n.id === d.id) return 1;
                    const isConnected = graphLinks.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) || 
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return isConnected ? 1 : 0.1;
                });
            } else {
                // Normal mode
                link.classed("highlighted", l => l.source.id === d.id || l.target.id === d.id)
                    .style("opacity", l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.2);
                
                node.select("circle").style("opacity", n => {
                    if (n.id === d.id) return 1;
                    const isConnected = graphLinks.some(l => 
                        (l.source.id === d.id && l.target.id === n.id) || 
                        (l.target.id === d.id && l.source.id === n.id)
                    );
                    return isConnected ? 1 : 0.4;
                });
            }
        })
        .on("mouseout", function(event, d) {
            if (!showingConnectionsOnly) {
                // Reset styling in normal mode
                d3.select(this).select("circle").classed("highlighted-node", false);
                link.classed("highlighted", false).style("opacity", 1);
                node.select("circle").style("opacity", 1);
            } else {
                // In connection-only mode, return to faded state
                d3.select(this).select("circle").classed("highlighted-node", false);
                link.style("opacity", 0.1);
                node.select("circle").style("opacity", 0.3);
                node.select("text").style("opacity", 0.3);
            }
        });

        // Add drag behavior (clean D3 pattern)
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        // Tick function (clean D3 pattern)
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Drag functions (clean D3 pattern)
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        // Control functions
        let showingConnectionsOnly = false;
        
        function highlightMultipleInheritance() {
            // Clear previous highlights
            node.select("circle").classed("highlighted-node", false).style("opacity", 1);
            link.classed("highlighted", false).style("opacity", 1);
            node.select("text").style("opacity", 1);
            
            // Find nodes with multiple parents
            const multiParentNodes = graphNodes.filter(n => n.parents.length > 1);
            const multiParentIds = multiParentNodes.map(n => n.id);
            
            // Highlight nodes with multiple inheritance
            node.select("circle").style("opacity", d => multiParentIds.includes(d.id) ? 1 : 0.2);
            node.select("text").style("opacity", d => multiParentIds.includes(d.id) ? 1 : 0.2);
            
            // Highlight all links to/from multiple inheritance nodes
            link.style("opacity", l => {
                return (multiParentIds.includes(l.target.id) || multiParentIds.includes(l.source.id)) ? 1 : 0.1;
            }).classed("highlighted", l => {
                return multiParentIds.includes(l.target.id) || multiParentIds.includes(l.source.id);
            });
            
            // Add explanation text
            svg.select("#explanation-text").remove();
            svg.append("text")
                .attr("id", "explanation-text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("fill", "#ff6b6b")
                .text("Multiple Inheritance Nodes: These matrix types satisfy multiple independent conditions")
                .append("tspan")
                .attr("x", width / 2)
                .attr("dy", "1.2em")
                .style("font-size", "12px")
                .style("font-weight", "normal")
                .text("Examples: Diagonal (Symmetric ‚à© Upper ‚à© Lower), Reflection (Orthogonal ‚à© Involutory), Zero (Scalar ‚à© Skew-Symmetric)");
        }
        
        function highlightNormalMatrices() {
            // Clear previous highlights
            node.select("circle").classed("highlighted-node", false).style("opacity", 1);
            link.classed("highlighted", false).style("opacity", 1);
            node.select("text").style("opacity", 1);
            
            // Find Normal node and all its descendants
            function findDescendants(nodeId, visited = new Set()) {
                if (visited.has(nodeId)) return [];
                visited.add(nodeId);
                
                const descendants = [nodeId];
                const children = graphLinks.filter(l => l.source.id === nodeId);
                
                for (const child of children) {
                    descendants.push(...findDescendants(child.target.id, visited));
                }
                
                return descendants;
            }
            
            const normalDescendants = findDescendants("Normal");
            
            // Highlight Normal and all its descendants
            node.select("circle").style("opacity", d => normalDescendants.includes(d.id) ? 1 : 0.2);
            node.select("text").style("opacity", d => normalDescendants.includes(d.id) ? 1 : 0.2);
            
            // Highlight links within the Normal family
            link.style("opacity", l => {
                return (normalDescendants.includes(l.source.id) && normalDescendants.includes(l.target.id)) ? 1 : 0.1;
            }).classed("highlighted", l => {
                return normalDescendants.includes(l.source.id) && normalDescendants.includes(l.target.id);
            });
            
            // Add explanation text
            svg.select("#explanation-text").remove();
            svg.append("text")
                .attr("id", "explanation-text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("fill", "#4caf50")
                .text("Normal Matrices: AA* = A*A (commute with conjugate transpose)")
                .append("tspan")
                .attr("x", width / 2)
                .attr("dy", "1.2em")
                .style("font-size", "12px")
                .style("font-weight", "normal")
                .text("Includes: Symmetric, Hermitian, Unitary, Orthogonal, Skew-Symmetric, Skew-Hermitian, and all their descendants");
        }
        
        function showOnlyConnections() {
            showingConnectionsOnly = !showingConnectionsOnly;
            
            if (showingConnectionsOnly) {
                // Make all links very faint
                link.style("opacity", 0.1);
                node.select("circle").style("opacity", 0.3);
                node.select("text").style("opacity", 0.3);
                
                // Add instruction text
                svg.append("text")
                    .attr("id", "instruction-text")
                    .attr("x", width / 2)
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .style("font-weight", "bold")
                    .style("fill", "#333")
                    .text("Hover over nodes to see their direct connections");
                    
                document.querySelector('button[onclick="showOnlyConnections()"]').textContent = "Show All";
            } else {
                // Reset to normal view
                link.style("opacity", 1);
                node.select("circle").style("opacity", 1);
                node.select("text").style("opacity", 1);
                svg.select("#instruction-text").remove();
                document.querySelector('button[onclick="showOnlyConnections()"]').textContent = "Show Only Direct Connections";
            }
        }

        function restartSimulation() {
            // Reset all fixed positions
            graphNodes.forEach(d => {
                d.fx = null;
                d.fy = null;
            });
            // Clear highlights and reset view
            node.select("circle").classed("highlighted-node", false).style("opacity", 1);
            link.classed("highlighted", false).style("opacity", 1);
            node.select("text").style("opacity", 1);
            svg.select("#instruction-text").remove();
            svg.select("#explanation-text").remove();
            showingConnectionsOnly = false;
            document.querySelector('button[onclick="showOnlyConnections()"]').textContent = "Show Only Direct Connections";
            // Restart simulation
            simulation.alpha(1).restart();
        }

        let animationRunning = true;
        function toggleAnimation() {
            if (animationRunning) {
                simulation.stop();
                animationRunning = false;
            } else {
                simulation.restart();
                animationRunning = true;
            }
        }

        function highlightPath(targetName) {
            // Clear previous highlights
            node.select("circle").classed("highlighted-node", false).style("opacity", 1);
            link.classed("highlighted", false).style("opacity", 1);
            node.select("text").style("opacity", 1);
            
            // Find all paths from root to target (BFS to find shortest paths)
            function findAllPaths(target) {
                const paths = [];
                const queue = [{ node: "Rectangular", path: ["Rectangular"] }];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const { node: current, path } = queue.shift();
                    
                    if (current === target) {
                        paths.push([...path]);
                        continue;
                    }
                    
                    // Find children
                    const children = graphLinks.filter(l => l.source.id === current);
                    for (const child of children) {
                        if (!path.includes(child.target.id)) { // Avoid cycles
                            queue.push({ 
                                node: child.target.id, 
                                path: [...path, child.target.id] 
                            });
                        }
                    }
                }
                
                return paths;
            }
            
            const paths = findAllPaths(targetName);
            const allPathNodes = new Set();
            
            // Collect all nodes in any path
            paths.forEach(path => path.forEach(nodeId => allPathNodes.add(nodeId)));
            
            // Highlight path nodes
            node.select("circle").classed("highlighted-node", d => allPathNodes.has(d.id));
            node.select("circle").style("opacity", d => allPathNodes.has(d.id) ? 1 : 0.2);
            node.select("text").style("opacity", d => allPathNodes.has(d.id) ? 1 : 0.2);
            
            // Highlight path links
            link.classed("highlighted", l => {
                return paths.some(path => {
                    const sourceIndex = path.indexOf(l.source.id);
                    const targetIndex = path.indexOf(l.target.id);
                    return sourceIndex !== -1 && targetIndex === sourceIndex + 1;
                });
            }).style("opacity", l => {
                const isInPath = paths.some(path => {
                    const sourceIndex = path.indexOf(l.source.id);
                    const targetIndex = path.indexOf(l.target.id);
                    return sourceIndex !== -1 && targetIndex === sourceIndex + 1;
                });
                return isInPath ? 1 : 0.1;
            });
            
            // Add explanation
            svg.select("#explanation-text").remove();
            svg.append("text")
                .attr("id", "explanation-text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("fill", "#2196f3")
                .text(`All inheritance paths to ${targetName} (${paths.length} path${paths.length !== 1 ? 's' : ''})`)
                .append("tspan")
                .attr("x", width / 2)
                .attr("dy", "1.2em")
                .style("font-size", "12px")
                .style("font-weight", "normal")
                .text(paths.length > 1 ? "Multiple paths show rich mathematical structure" : "Single inheritance path");
        }

        // Add zoom functionality
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", function(event) {
                container.attr("transform", event.transform);
            });
        
        svg.call(zoom);
    </script>
</body>
</html>