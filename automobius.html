<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WIP Automorphic Möbius Interpolation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(100, 255, 100, 0.3);
        }
        
        .header h1 {
            color: #64ffda;
            font-size: 2.5em;
            margin: 0;
            text-shadow: 0 0 20px rgba(100, 255, 218, 0.5);
        }
        
        .header p {
            color: #b0b0b0;
            font-size: 1.1em;
            margin: 10px 0;
        }
        
        .phase-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .phase-box {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(100, 255, 100, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .phase-title {
            color: #64ffda;
            font-size: 1.3em;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .status-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #64ffda;
            text-align: center;
        }
        
        .status-value {
            font-size: 1.8em;
            color: #64ffda;
            font-weight: bold;
        }
        
        .status-label {
            font-size: 0.9em;
            color: #b0b0b0;
            margin-top: 5px;
        }
        
        .console-output {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
            color: #00ff00;
            height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .progress-bar {
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            height: 20px;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ffda, #00ff88);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .matrix-viz {
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            gap: 1px;
            background: #333;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .matrix-cell {
            aspect-ratio: 1;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            background: linear-gradient(45deg, #64ffda, #00ff88);
            border: none;
            color: #000;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.4);
        }
        
        .btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .grade-a { color: #00ff00; }
        .grade-b { color: #ffff00; }
        .grade-c { color: #ff8800; }
        .grade-d { color: #ff4444; }
        .grade-f { color: #ff0000; }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .error-visualization {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .slider-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(100, 255, 100, 0.2);
        }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .slider-group label {
            color: #64ffda;
            font-weight: bold;
            font-size: 1.1em;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #64ffda, #00ff88);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(100, 255, 218, 0.5);
        }
        
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #64ffda, #00ff88);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 10px rgba(100, 255, 218, 0.5);
        }
        
        .slider-info {
            font-size: 0.9em;
            color: #b0b0b0;
            font-style: italic;
        }
        
        .scaling-results {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(100, 255, 100, 0.2);
        }
        
        .scaling-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .scaling-item {
            background: rgba(100, 255, 218, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
        
        .scaling-size {
            font-size: 1.2em;
            color: #64ffda;
            font-weight: bold;
        }
        
        .scaling-condition {
            font-size: 0.9em;
            margin: 5px 0;
        }
        
        .scaling-error {
            font-size: 0.9em;
        }
        
        .coeff-box {
            background: rgba(100, 255, 218, 0.1);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.8em;
            border: 1px solid rgba(100, 255, 218, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WIP AUTOMORPHIC FORMS</h1>
            <p>Möbius Interpolation via φ(q)-Dimensional Exact Computation</p>
            <p>Level q = 1009, Target Dimensions = 1008</p>
            <p>PLEASE NOTE: This is a preview, and much of what you see is placeholders. Do not trust results yet.</p>
        </div>
        
        <div class="controls">
            <button class="btn" id="runBtn" onclick="runComputation()">Run Computation</button>
            <button class="btn" id="resetBtn" onclick="resetComputation()">Reset</button>
            <button class="btn" id="exportBtn" onclick="exportResults()" disabled>Export Results</button>
            <button class="btn" id="autoScaleBtn" onclick="runAutoScale()">Auto Scale Test</button>
        </div>
        
        <div class="slider-container">
            <div class="slider-group">
                <label for="systemSizeSlider">System Size: <span id="systemSizeValue">200</span></label>
                <input type="range" id="systemSizeSlider" min="20" max="1008" value="200" step="20">
                <div class="slider-info">Controls the n×n matrix size. Target: φ(1009) = 1008 for full coverage.</div>
            </div>
            
            <div class="slider-group">
                <label for="regularizationSlider">Regularization: <span id="regularizationValue">1e-12</span></label>
                <input type="range" id="regularizationSlider" min="-15" max="-6" value="-12" step="0.5">
                <div class="slider-info">Numerical regularization parameter. Smaller = more accurate but less stable.</div>
            </div>
            
            <div class="slider-group">
                <label for="orthogonalizationSlider">Orthogonalization Method: <span id="orthogonalizationValue">QR</span></label>
                <input type="range" id="orthogonalizationSlider" min="0" max="2" value="1" step="1">
                <div class="slider-info">0: None, 1: QR (best), 2: Gram-Schmidt</div>
            </div>
            
            <div class="slider-group">
                <label for="basisTypeSlider">Basis Type: <span id="basisTypeValue">Sine</span></label>
                <input type="range" id="basisTypeSlider" min="0" max="3" value="0" step="1">
                <div class="slider-info">0: Sine, 1: Chebyshev, 2: Fourier, 3: Mixed</div>
            </div>
        </div>
        
        <div class="console-output" id="console"></div>
        
        <div class="scaling-results" id="scalingResults" style="display: none;">
            <div class="phase-title">Scaling Analysis Results</div>
            <div class="scaling-grid" id="scalingGrid"></div>
        </div>
        
        <div class="status-grid">
            <div class="status-card">
                <div class="status-value" id="basisSize">0</div>
                <div class="status-label">Basis Functions</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="coverage">0%</div>
                <div class="status-label">Coverage</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="conditionNumber">-</div>
                <div class="status-label">Condition Number</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="maxError">-</div>
                <div class="status-label">Max Error</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="stabilityGrade">-</div>
                <div class="status-label">Stability Grade</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="qualityGrade">-</div>
                <div class="status-label">Quality Grade</div>
            </div>
        </div>
        
        <div class="phase-container">
            <div class="phase-box">
                <div class="phase-title">Interpolation Quality</div>
                <div class="chart-container">
                    <canvas id="errorChart"></canvas>
                </div>
            </div>
            
            <div class="phase-box">
                <div class="phase-title">Möbius vs Interpolation</div>
                <div class="chart-container">
                    <canvas id="comparisonChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="phase-container">
            <div class="phase-box">
                <div class="phase-title">Basis Composition</div>
                <div class="chart-container">
                    <canvas id="basisChart"></canvas>
                </div>
            </div>
            
            <div class="phase-box">
                <div class="phase-title">Condition Number Evolution</div>
                <div class="chart-container">
                    <canvas id="conditionChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="phase-box full-width">
            <div class="phase-title">Eisenstein Continuum Forms</div>
            <div class="coefficient-display" id="eisensteinCoeffs"></div>
        </div>
        
        <div class="error-visualization">
            <div class="phase-title">Matrix Conditioning Visualization</div>
            <div class="matrix-viz" id="matrixViz"></div>
        </div>
    </div>

    <script>
        // Mathematical utilities
        function gcd(a, b) {
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        function eulerPhi(n) {
            let result = n;
            for (let p = 2; p * p <= n; p++) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
            }
            if (n > 1) result -= result / n;
            return Math.floor(result);
        }
        
        function moebius(n) {
            if (n === 1) return 1;
            let p = 0;
            for (let i = 2; i <= Math.sqrt(n); i++) {
                if (n % i === 0) {
                    if (n % (i * i) === 0) return 0;
                    p++;
                }
            }
            if (n > 1) p++;
            return p % 2 === 0 ? 1 : -1;
        }
        
        function divisors(n) {
            const divs = [];
            for (let i = 1; i <= Math.sqrt(n); i++) {
                if (n % i === 0) {
                    divs.push(i);
                    if (i !== n / i) divs.push(n / i);
                }
            }
            return divs.sort((a, b) => a - b);
        }
        
        // Enhanced basis generation with different types
        function generateBasis(systemSize, basisType) {
            const rawBasis = [];
            
            switch(basisType) {
                case 0: // Sine basis
                    for (let k = 0; k < systemSize; k++) {
                        const func = [];
                        for (let n = 1; n <= systemSize; n++) {
                            const freq = (k + 1) * Math.PI / (systemSize + 1);
                            const coeff = Math.sin(freq * n);
                            func.push(coeff);
                        }
                        rawBasis.push(func);
                    }
                    break;
                    
                case 1: // Chebyshev basis
                    for (let k = 0; k < systemSize; k++) {
                        const func = [];
                        for (let n = 1; n <= systemSize; n++) {
                            const x = (2 * n - systemSize - 1) / systemSize; // Map to [-1, 1]
                            const clampedX = Math.max(-1, Math.min(1, x));
                            const coeff = Math.cos(k * Math.acos(clampedX));
                            func.push(coeff);
                        }
                        rawBasis.push(func);
                    }
                    break;
                    
                case 2: // Fourier basis
                    for (let k = 0; k < systemSize; k++) {
                        const func = [];
                        for (let n = 1; n <= systemSize; n++) {
                            const freq = 2 * Math.PI * k * n / systemSize;
                            const coeff = (k % 2 === 0) ? Math.cos(freq) : Math.sin(freq);
                            func.push(coeff);
                        }
                        rawBasis.push(func);
                    }
                    break;
                    
                case 3: // Mixed basis
                    for (let k = 0; k < systemSize; k++) {
                        const func = [];
                        for (let n = 1; n <= systemSize; n++) {
                            const sineFreq = (k + 1) * Math.PI / (systemSize + 1);
                            const fourierFreq = 2 * Math.PI * k * n / systemSize;
                            const sine = Math.sin(sineFreq * n);
                            const fourier = Math.cos(fourierFreq);
                            const coeff = (sine + 0.3 * fourier) / 1.3;
                            func.push(coeff);
                        }
                        rawBasis.push(func);
                    }
                    break;
            }
            
            return rawBasis;
        }
        
        // Enhanced orthogonalization with method selection
        function applyOrthogonalization(basisFunctions, method) {
            switch(method) {
                case 0: // No orthogonalization
                    return basisFunctions;
                case 1: // QR decomposition
                    return qrOrthogonalization(basisFunctions);
                case 2: // Gram-Schmidt
                    return gramSchmidtBasisOrthogonalization(basisFunctions);
                default:
                    return qrOrthogonalization(basisFunctions);
            }
        }
        
        // Global variables and slider management
        let computationState = {
            running: false,
            autoScaling: false,
            phase: 0,
            results: null,
            charts: {},
            parameters: {
                systemSize: 50,
                regularization: 1e-12,
                orthogonalizationMethod: 1, // 0: None, 1: QR, 2: Gram-Schmidt
                basisType: 0 // 0: Sine, 1: Chebyshev, 2: Fourier, 3: Mixed
            }
        };
        
        // Slider event handlers
        function initializeSliders() {
            const systemSizeSlider = document.getElementById('systemSizeSlider');
            const regularizationSlider = document.getElementById('regularizationSlider');
            const orthogonalizationSlider = document.getElementById('orthogonalizationSlider');
            const basisTypeSlider = document.getElementById('basisTypeSlider');
            
            systemSizeSlider.addEventListener('input', function() {
                computationState.parameters.systemSize = parseInt(this.value);
                const size = this.value;
                const coverage = (size / 1008 * 100).toFixed(1);
                document.getElementById('systemSizeValue').textContent = `${size} (${coverage}%)`;
            });
            
            regularizationSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                computationState.parameters.regularization = Math.pow(10, value);
                document.getElementById('regularizationValue').textContent = `1e${value}`;
            });
            
            orthogonalizationSlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                computationState.parameters.orthogonalizationMethod = value;
                const methods = ['None', 'QR', 'Gram-Schmidt'];
                document.getElementById('orthogonalizationValue').textContent = methods[value];
            });
            
            basisTypeSlider.addEventListener('input', function() {
                const value = parseInt(this.value);
                computationState.parameters.basisType = value;
                const types = ['Sine', 'Chebyshev', 'Fourier', 'Mixed'];
                document.getElementById('basisTypeValue').textContent = types[value];
            });
        }
        
        let consoleElement = document.getElementById('console');
        
        function log(message, color = '#00ff00') {
            const timestamp = new Date().toLocaleTimeString();
            consoleElement.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }
        
        function clearConsole() {
            consoleElement.innerHTML = '';
        }
        
        function updateStatus(key, value, className = '') {
            const element = document.getElementById(key);
            if (element) {
                element.textContent = value;
                if (className) {
                    element.className = `status-value ${className}`;
                }
            }
        }
        
        // Holomorphic cusp forms simulation with better conditioning
        function generateHolomorphicForms(q, count = 84) {
            const forms = [];
            for (let i = 0; i < count; i++) {
                const coeffs = [];
                for (let n = 1; n <= q; n++) {
                    if (gcd(n, q) === 1) {
                        // Use orthogonal trigonometric basis with exponential decay
                        const phase = 2 * Math.PI * (i + 1) * n / q;
                        const amplitude = Math.exp(-n / (q * 0.05)); // Slower decay
                        const coeff = (Math.sin(phase) + Math.cos(phase * 1.618)) * amplitude;
                        // Normalize properly
                        coeffs.push(coeff / Math.sqrt(n + 1));
                    } else {
                        coeffs.push(0);
                    }
                }
                forms.push(coeffs);
            }
            return forms;
        }
        
        // Eisenstein series simulation with proper normalization
        function generateEisensteinForms(q, count = 2) {
            const forms = [];
            for (let i = 0; i < count; i++) {
                const coeffs = [];
                for (let n = 1; n <= q; n++) {
                    if (gcd(n, q) === 1) {
                        // More stable Eisenstein series approximation
                        const divs = divisors(n);
                        const sigma = divs.reduce((sum, d) => sum + Math.pow(d, 0.5 + i * 0.1), 0);
                        // Better normalization to avoid large coefficients
                        const normFactor = Math.sqrt(Math.log(n + 1) + 1);
                        coeffs.push(sigma / normFactor);
                    } else {
                        coeffs.push(0);
                    }
                }
                forms.push(coeffs);
            }
            return forms;
        }
        
        // Eisenstein continuum forms with improved numerical stability
        function generateEisensteinContinuum(q, count = 922) {
            const forms = [];
            const tSpacing = Math.PI / Math.log(q);
            
            for (let j = 0; j < count; j++) {
                const t = tSpacing * (j + 1);
                const coeffs = [];
                
                for (let n = 1; n <= q; n++) {
                    if (gcd(n, q) === 1) {
                        // Improved sigma_{2it}(n) computation with regularization
                        let sigma2itReal = 0;
                        const divs = divisors(n);
                        
                        // Add regularization to prevent oscillations
                        const regularization = Math.exp(-t * t / (2 * q));
                        
                        divs.forEach(d => {
                            const logD = Math.log(d);
                            sigma2itReal += Math.cos(2 * t * logD) * regularization;
                        });
                        
                        // Better normalization for numerical stability
                        const normFactor = Math.sqrt(n) * (1 + t * t / q);
                        coeffs.push(sigma2itReal / normFactor);
                    } else {
                        coeffs.push(0);
                    }
                }
                forms.push(coeffs);
            }
            return forms;
        }
        
        function qrOrthogonalization(basisFunctions) {
            // Simplified QR decomposition approach
            const n = basisFunctions.length;
            const m = basisFunctions[0].length;
            
            try {
                // Create matrix from basis functions (columns are basis functions)
                const A = [];
                for (let i = 0; i < m; i++) {
                    const row = [];
                    for (let j = 0; j < n; j++) {
                        row.push(basisFunctions[j][i]);
                    }
                    A.push(row);
                }
                
                // Use math.js QR decomposition
                const matA = math.matrix(A);
                const qrResult = math.qr(matA);
                const Q = qrResult.Q;
                
                // Extract orthogonal basis functions from Q matrix
                const orthogonalBasis = [];
                for (let j = 0; j < n; j++) {
                    const func = [];
                    for (let i = 0; i < m; i++) {
                        func.push(Q.get([i, j]));
                    }
                    orthogonalBasis.push(func);
                }
                
                // Explicit renormalization to ensure ||v||_2 = 1
                orthogonalBasis.forEach(v => {
                    const norm = Math.sqrt(v.reduce((s, x) => s + x*x, 0));
                    if (norm > 1e-15) {
                        for (let i = 0; i < v.length; i++) {
                            v[i] /= norm;
                        }
                    }
                });
                
                return orthogonalBasis;
                
            } catch (error) {
                console.warn("QR decomposition failed, using Gram-Schmidt fallback");
                console.warn("Error details:", error.message);
                return gramSchmidtBasisOrthogonalization(basisFunctions);
            }
        }
        
        // Auto-scaling test function
        async function runAutoScale() {
            if (computationState.running || computationState.autoScaling) return;
            
            computationState.autoScaling = true;
            const btn = document.getElementById('autoScaleBtn');
            btn.disabled = true;
            btn.textContent = 'Running Auto Scale...';
            btn.classList.add('auto-scale-running');
            
            clearConsole();
            log("================================================================================", '#ffd93d');
            log("AUTO-SCALING ANALYSIS", '#ffd93d');
            log("================================================================================", '#ffd93d');
            log("");
            
            const scalingResults = [];
            const testSizes = [20, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1008];
            
            log(`Testing scaling up to φ(1009) = 1008 dimensions...`, '#ffd93d');
            log(`This may take several minutes for larger sizes`, '#ffff00');
            log("");
            
            for (const size of testSizes) {
                if (!computationState.autoScaling) break; // Allow interruption
                
                const startTime = Date.now();
                log(`Testing system size: ${size}×${size} (${(size/1008*100).toFixed(1)}% coverage)`, '#64ffda');
                
                try {
                    // Generate basis
                    const rawBasis = generateBasis(size, computationState.parameters.basisType);
                    const orthogonalBasis = applyOrthogonalization(rawBasis, computationState.parameters.orthogonalizationMethod);
                    
                    // Build matrix
                    const matrix = [];
                    for (let i = 0; i < size; i++) {
                        const row = [];
                        for (let j = 0; j < size; j++) {
                            row.push(orthogonalBasis[j][i]);
                        }
                        matrix.push(row);
                    }
                    
                    // Compute metrics
                    const conditionNumber = matrixCondition(matrix);
                    
                    // For larger sizes, test with smaller target vector to save time
                    const testSize = Math.min(size, 100);
                    const testTarget = [];
                    for (let n = 1; n <= testSize; n++) {
                        testTarget.push(moebius(n));
                    }
                    
                    // Create reduced system for testing
                    const testMatrix = matrix.slice(0, testSize).map(row => row.slice(0, testSize));
                    const solution = solveSystemImproved(testMatrix, testTarget);
                    const reconstruction = testMatrix.map(row => 
                        row.reduce((sum, val, j) => sum + val * solution[j], 0)
                    );
                    
                    const errors = reconstruction.map((val, i) => Math.abs(val - testTarget[i]));
                    const maxError = Math.max(...errors);
                    
                    const elapsed = Date.now() - startTime;
                    
                    scalingResults.push({
                        size: size,
                        condition: conditionNumber,
                        maxError: maxError,
                        stability: getStabilityGrade(conditionNumber),
                        quality: getQualityGrade(maxError),
                        time: elapsed
                    });
                    
                    log(`  Condition: ${conditionNumber.toExponential(2)}, Error: ${maxError.toExponential(2)}, Time: ${elapsed}ms`);
                    
                    // Add longer delay for larger systems
                    const delay = size > 500 ? 500 : 100;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                } catch (error) {
                    log(`  Failed: ${error.message}`, '#ff6b6b');
                    scalingResults.push({
                        size: size,
                        condition: 1e12,
                        maxError: 1,
                        stability: 'F',
                        quality: 'F',
                        time: 0
                    });
                }
            }
            
            // Display results
            displayScalingResults(scalingResults);
            
            log("");
            log("Auto-scaling analysis complete!", '#64ffda');
            
            computationState.autoScaling = false;
            btn.disabled = false;
            btn.textContent = 'Auto Scale Test';
            btn.classList.remove('auto-scale-running');
        }
        
        function getStabilityGrade(condition) {
            if (condition < 2) return 'A+';
            if (condition < 5) return 'A';
            if (condition < 10) return 'B';
            if (condition < 100) return 'C';
            if (condition < 1000) return 'D';
            return 'F';
        }
        
        function getQualityGrade(error) {
            if (error < 1e-12) return 'A+';
            if (error < 1e-10) return 'A';
            if (error < 1e-8) return 'B';
            if (error < 1e-6) return 'C';
            if (error < 1e-4) return 'D';
            return 'F';
        }
        
        function displayScalingResults(results) {
            const container = document.getElementById('scalingResults');
            const grid = document.getElementById('scalingGrid');
            
            grid.innerHTML = '';
            
            results.forEach(result => {
                const item = document.createElement('div');
                item.className = 'scaling-item';
                
                const stabilityClass = result.stability.toLowerCase().replace('+', '-plus');
                const qualityClass = result.quality.toLowerCase().replace('+', '-plus');
                
                item.innerHTML = `
                    <div class="scaling-size">${result.size}×${result.size}</div>
                    <div class="scaling-condition grade-${stabilityClass}">${result.condition.toExponential(1)}</div>
                    <div class="scaling-error grade-${qualityClass}">${result.maxError.toExponential(1)}</div>
                    <div>Coverage: ${(result.size/1008*100).toFixed(1)}%</div>
                    <div>Time: ${result.time || 0}ms</div>
                    <div>Stability: <span class="grade-${stabilityClass}">${result.stability}</span></div>
                    <div>Quality: <span class="grade-${qualityClass}">${result.quality}</span></div>
                `;
                
                grid.appendChild(item);
            });
            
            container.style.display = 'block';
        }
        
        function gramSchmidtBasisOrthogonalization(basisFunctions) {
            // Apply Gram-Schmidt orthogonalization to basis functions
            const n = basisFunctions.length;
            const m = basisFunctions[0].length;
            const orthogonal = [];
            
            for (let i = 0; i < n; i++) {
                // Start with current basis function
                let current = [...basisFunctions[i]];
                
                // Orthogonalize against all previous functions
                for (let j = 0; j < i; j++) {
                    const prev = orthogonal[j];
                    
                    // Compute dot product
                    let dot = 0;
                    for (let k = 0; k < m; k++) {
                        dot += current[k] * prev[k];
                    }
                    
                    // Subtract projection
                    for (let k = 0; k < m; k++) {
                        current[k] -= dot * prev[k];
                    }
                }
                
                // Normalize to unit length
                let norm = 0;
                for (let k = 0; k < m; k++) {
                    norm += current[k] * current[k];
                }
                norm = Math.sqrt(norm);
                
                if (norm > 1e-15) {
                    for (let k = 0; k < m; k++) {
                        current[k] /= norm;
                    }
                } else {
                    // Handle degenerate case
                    current = new Array(m).fill(0);
                    if (i < m) current[i] = 1;
                }
                
                orthogonal.push(current);
            }
            
            // Additional renormalization pass to ensure ||v||_2 = 1
            orthogonal.forEach(v => {
                const norm = Math.sqrt(v.reduce((s, x) => s + x*x, 0));
                if (norm > 1e-15) {
                    for (let i = 0; i < v.length; i++) {
                        v[i] /= norm;
                    }
                }
            });
            
            return orthogonal;
        }
        
        function gramSchmidtOrthogonalization(matrix) {
            // Apply Gram-Schmidt orthogonalization to improve numerical conditioning
            const m = matrix.length;
            const n = matrix[0].length;
            const orthogonalized = [];
            
            // Initialize with original matrix
            for (let i = 0; i < m; i++) {
                orthogonalized[i] = [...matrix[i]];
            }
            
            // Gram-Schmidt process on columns
            for (let j = 0; j < n; j++) {
                // Extract column j
                const col = [];
                for (let i = 0; i < m; i++) {
                    col[i] = orthogonalized[i][j];
                }
                
                // Orthogonalize against previous columns
                for (let k = 0; k < j; k++) {
                    const prevCol = [];
                    for (let i = 0; i < m; i++) {
                        prevCol[i] = orthogonalized[i][k];
                    }
                    
                    // Compute dot product
                    let dot = 0;
                    for (let i = 0; i < m; i++) {
                        dot += col[i] * prevCol[i];
                    }
                    
                    // Compute norm squared of previous column
                    let normSq = 0;
                    for (let i = 0; i < m; i++) {
                        normSq += prevCol[i] * prevCol[i];
                    }
                    
                    // Subtract projection
                    if (normSq > 1e-15) {
                        const proj = dot / normSq;
                        for (let i = 0; i < m; i++) {
                            col[i] -= proj * prevCol[i];
                        }
                    }
                }
                
                // Normalize column
                let norm = 0;
                for (let i = 0; i < m; i++) {
                    norm += col[i] * col[i];
                }
                norm = Math.sqrt(norm);
                
                if (norm > 1e-15) {
                    for (let i = 0; i < m; i++) {
                        orthogonalized[i][j] = col[i] / norm;
                    }
                } else {
                    // Handle zero columns
                    for (let i = 0; i < m; i++) {
                        orthogonalized[i][j] = 0;
                    }
                }
            }
            
            return orthogonalized;
        }
        
        // Matrix operations
        function createMatrix(forms, windowSize) {
            const matrix = [];
            for (let i = 0; i < windowSize; i++) {
                const row = [];
                for (let j = 0; j < forms.length; j++) {
                    row.push(forms[j][i] || 0);
                }
                matrix.push(row);
            }
            return matrix;
        }
        
        function matrixCondition(matrix) {
            // Robust spectral condition number computation
            try {
                const A = math.matrix(matrix);
                
                // Try different SVD approaches
                let svdResult;
                try {
                    // Method 1: Direct SVD
                    svdResult = math.svd(A);
                } catch (e1) {
                    try {
                        // Method 2: Via eigenvalues of A^T A
                        const AT = math.transpose(A);
                        const ATA = math.multiply(AT, A);
                        const eigenvals = math.eigs(ATA).values;
                        
                        // Convert complex eigenvalues to real (they should be real for A^T A)
                        const realEigenvals = eigenvals.map(val => 
                            typeof val === 'number' ? val : val.re || Math.sqrt(val.re*val.re + val.im*val.im)
                        ).filter(val => val > 1e-14);
                        
                        realEigenvals.sort((a, b) => b - a); // Descending order
                        
                        const maxEig = realEigenvals[0];
                        const minEig = realEigenvals[realEigenvals.length - 1];
                        
                        // Condition number is sqrt(max/min) for A^T A
                        const condition = Math.sqrt(maxEig / minEig);
                        return Math.max(1.0, Math.min(condition, 1e10));
                        
                    } catch (e2) {
                        // Method 3: Simple norm ratio estimation
                        const n = matrix.length;
                        
                        // Estimate using matrix norms
                        let maxNorm = 0;
                        let minNorm = Infinity;
                        
                        // Check row norms
                        for (let i = 0; i < n; i++) {
                            let rowNorm = 0;
                            for (let j = 0; j < n; j++) {
                                rowNorm += matrix[i][j] * matrix[i][j];
                            }
                            rowNorm = Math.sqrt(rowNorm);
                            maxNorm = Math.max(maxNorm, rowNorm);
                            minNorm = Math.min(minNorm, rowNorm);
                        }
                        
                        if (minNorm > 1e-15) {
                            return Math.max(1.0, maxNorm / minNorm);
                        } else {
                            return 1e6; // Singular matrix
                        }
                    }
                }
                
                // If SVD succeeded, extract singular values
                const s = svdResult.s || svdResult.S;
                if (!s) {
                    throw new Error("SVD result has no singular values");
                }
                
                // Convert to array if needed
                const singularValues = Array.isArray(s) ? s : s.toArray();
                
                // Filter out near-zero singular values
                const validSingularValues = singularValues.filter(val => val > 1e-14);
                
                if (validSingularValues.length === 0) {
                    return 1e12;
                }
                
                // Sort in descending order
                validSingularValues.sort((a, b) => b - a);
                
                const maxS = validSingularValues[0];
                const minS = validSingularValues[validSingularValues.length - 1];
                
                const condition = maxS / minS;
                return Math.max(1.0, Math.min(condition, 1e10));
                
            } catch (e) {
                console.warn("All condition number methods failed:", e.message);
                
                // Final fallback: diagonal dominance
                const n = matrix.length;
                let maxDiag = -Infinity;
                let minDiag = Infinity;
                
                for (let i = 0; i < n; i++) {
                    const diag = Math.abs(matrix[i][i]);
                    if (diag > 1e-15) {
                        maxDiag = Math.max(maxDiag, diag);
                        minDiag = Math.min(minDiag, diag);
                    }
                }
                
                if (minDiag > 1e-15 && maxDiag > -Infinity) {
                    return Math.max(1.0, maxDiag / minDiag);
                } else {
                    return 1e3; // Conservative fallback
                }
            }
        }
        
        function solveSystem(matrix, target) {
            try {
                const A = math.matrix(matrix);
                const b = math.matrix(target);
                
                // Use SVD-based solution for better numerical stability
                const svd = math.svd(A);
                const U = svd.U;
                const s = svd.s;
                const V = svd.V;
                
                // Regularized pseudoinverse
                const tolerance = 1e-12;
                const sInv = s.map(val => val > tolerance ? 1/val : 0);
                
                // Compute solution: x = V * diag(s^-1) * U^T * b
                const UT = math.transpose(U);
                const UTb = math.multiply(UT, b);
                
                // Apply regularized inverse
                const temp = UTb.map((val, i) => val * sInv[i]);
                const solution = math.multiply(V, temp);
                
                return math.flatten(solution);
            } catch (e) {
                // Fallback to regularized least squares
                try {
                    const A = math.matrix(matrix);
                    const b = math.matrix(target);
                    const AT = math.transpose(A);
                    const ATA = math.multiply(AT, A);
                    
                    // Add Tikhonov regularization
                    const lambda = 1e-8;
                    const I = math.identity(ATA.size()[0]);
                    const regularizedATA = math.add(ATA, math.multiply(lambda, I));
                    
                    const ATb = math.multiply(AT, b);
                    const solution = math.lusolve(regularizedATA, ATb);
                    return math.flatten(solution);
                } catch (e2) {
                    console.warn("Fallback to zero solution due to numerical issues");
                    return new Array(matrix[0].length).fill(0);
                }
            }
        }
        
        // Visualization functions
        function initializeCharts() {
            const chartConfig = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        labels: { color: '#e0e0e0' }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#e0e0e0' },
                        grid: { color: 'rgba(224, 224, 224, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#e0e0e0' },
                        grid: { color: 'rgba(224, 224, 224, 0.1)' }
                    }
                }
            };
            
            // Error chart
            computationState.charts.error = new Chart(document.getElementById('errorChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Interpolation Error',
                        data: [],
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartConfig,
                    scales: {
                        ...chartConfig.scales,
                        y: { 
                            ...chartConfig.scales.y,
                            type: 'logarithmic'
                        }
                    }
                }
            });
            
            // Comparison chart
            computationState.charts.comparison = new Chart(document.getElementById('comparisonChart'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Möbius Function',
                        data: [],
                        backgroundColor: '#64ffda',
                        pointRadius: 6
                    }, {
                        label: 'Interpolation',
                        data: [],
                        backgroundColor: '#ff6b6b',
                        pointRadius: 4
                    }]
                },
                options: chartConfig
            });
            
            // Basis composition chart
            computationState.charts.basis = new Chart(document.getElementById('basisChart'), {
                type: 'doughnut',
                data: {
                    labels: ['Holomorphic', 'Eisenstein', 'Continuum'],
                    datasets: [{
                        data: [0, 0, 0],
                        backgroundColor: ['#64ffda', '#ff6b6b', '#ffd93d']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#e0e0e0' }
                        }
                    }
                }
            });
            
            // Condition number evolution
            computationState.charts.condition = new Chart(document.getElementById('conditionChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Condition Number',
                        data: [],
                        borderColor: '#ffd93d',
                        backgroundColor: 'rgba(255, 217, 61, 0.1)',
                        fill: true
                    }]
                },
                options: {
                    ...chartConfig,
                    scales: {
                        ...chartConfig.scales,
                        y: { 
                            ...chartConfig.scales.y,
                            type: 'logarithmic'
                        }
                    }
                }
            });
        }
        
        function updateCharts(results) {
            const { errors, mobius, interpolation, conditionHistory } = results;
            
            // Update error chart
            const errorData = errors.map((err, i) => ({ x: i + 1, y: Math.abs(err) + 1e-16 }));
            computationState.charts.error.data.labels = errorData.map(d => d.x);
            computationState.charts.error.data.datasets[0].data = errorData.map(d => d.y);
            computationState.charts.error.update();
            
            // Update comparison chart
            const comparisonData = mobius.slice(0, 50).map((val, i) => ({ x: i + 1, y: val }));
            const interpolationData = interpolation.slice(0, 50).map((val, i) => ({ x: i + 1, y: val }));
            computationState.charts.comparison.data.datasets[0].data = comparisonData;
            computationState.charts.comparison.data.datasets[1].data = interpolationData;
            computationState.charts.comparison.update();
            
            // Update basis composition
            computationState.charts.basis.data.datasets[0].data = [
                results.basisSizes.holomorphic,
                results.basisSizes.eisenstein,
                results.basisSizes.continuum
            ];
            computationState.charts.basis.update();
            
            // Update condition number evolution
            computationState.charts.condition.data.labels = conditionHistory.map((_, i) => i + 1);
            computationState.charts.condition.data.datasets[0].data = conditionHistory;
            computationState.charts.condition.update();
        }
        
        function visualizeMatrix(matrix) {
            const viz = document.getElementById('matrixViz');
            viz.innerHTML = '';
            
            const sampleSize = Math.min(20, matrix.length);
            const sampleMatrix = matrix.slice(0, sampleSize);
            
            // Find min/max for color scaling
            let minVal = Infinity, maxVal = -Infinity;
            sampleMatrix.forEach(row => {
                row.slice(0, 20).forEach(val => {
                    minVal = Math.min(minVal, val);
                    maxVal = Math.max(maxVal, val);
                });
            });
            
            sampleMatrix.forEach(row => {
                row.slice(0, 20).forEach(val => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    
                    // Color based on value
                    const normalized = (val - minVal) / (maxVal - minVal);
                    const hue = normalized * 240; // Blue to red
                    cell.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;
                    
                    cell.title = `Value: ${val.toFixed(4)}`;
                    viz.appendChild(cell);
                });
            });
        }
        
        function displayEisensteinCoeffs(forms) {
            const container = document.getElementById('eisensteinCoeffs');
            container.innerHTML = '';
            
            // Show first few forms
            const sampleForms = forms.slice(0, 5);
            sampleForms.forEach((form, i) => {
                const box = document.createElement('div');
                box.className = 'coeff-box';
                box.innerHTML = `
                    <div>Form ${i + 1}</div>
                    <div>${form.slice(0, 3).map(c => c.toFixed(3)).join(', ')}...</div>
                `;
                container.appendChild(box);
            });
        }
        
        // Main computation with completely revised approach
        async function runComputation() {
            if (computationState.running) return;
            
            computationState.running = true;
            document.getElementById('runBtn').disabled = true;
            document.getElementById('exportBtn').disabled = true;
            
            clearConsole();
            log("================================================================================", '#64ffda');
            log("TRUE AUTOMORPHIC FORMS MÖBIUS INTERPOLATION", '#64ffda');
            log("================================================================================", '#64ffda');
            log("");
            
            const q = 1009;
            const targetDim = eulerPhi(q);
            
            log(`Target level: q = ${q}`);
            log(`Target dimensions: φ(${q}) = ${targetDim}`);
            log("");
            
            try {
                // Phase 1: Generate a well-conditioned basis
                log("PHASE 1: Building Well-Conditioned Basis", '#ffd93d');
                log("-".repeat(50));
                
                // Use parameters from sliders
                const systemSize = computationState.parameters.systemSize;
                const basisType = computationState.parameters.basisType;
                const orthMethod = computationState.parameters.orthogonalizationMethod;
                
                const basisTypes = ['Sine', 'Chebyshev', 'Fourier', 'Mixed'];
                const orthMethods = ['None', 'QR', 'Gram-Schmidt'];
                
                log(`System size: ${systemSize} × ${systemSize}`);
                log(`Basis type: ${basisTypes[basisType]}`);
                log(`Orthogonalization: ${orthMethods[orthMethod]}`);
                
                // Generate basis using selected type
                const rawBasis = generateBasis(systemSize, basisType);
                
                // Apply orthogonalization using selected method
                const orthogonalBasis = applyOrthogonalization(rawBasis, orthMethod);
                
                log(`Built ${systemSize} basis functions`);
                log(`Applied ${orthMethods[orthMethod]} orthogonalization`);
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Phase 2: Build coefficient matrix
                log("");
                log("PHASE 2: Matrix Construction", '#ffd93d');
                log("-".repeat(50));
                
                const matrix = [];
                for (let i = 0; i < systemSize; i++) {
                    const row = [];
                    for (let j = 0; j < systemSize; j++) {
                        row.push(orthogonalBasis[j][i]);
                    }
                    matrix.push(row);
                }
                
                // Compute condition number
                const conditionNumber = matrixCondition(matrix);
                log(`Condition number: ${conditionNumber.toExponential(2)}`);
                
                // Diagnostic: Check if matrix is close to orthogonal (safer method)
                try {
                    const matA = math.matrix(matrix);
                    const matAT = math.transpose(matA);
                    const product = math.multiply(matAT, matA);
                    
                    // Compute orthogonality error manually
                    let orthogonalityError = 0;
                    for (let i = 0; i < systemSize; i++) {
                        for (let j = 0; j < systemSize; j++) {
                            const expected = (i === j) ? 1 : 0;
                            const actual = product.get([i, j]);
                            const diff = actual - expected;
                            orthogonalityError += diff * diff;
                        }
                    }
                    orthogonalityError = Math.sqrt(orthogonalityError);
                    
                    log(`Orthogonality error: ${orthogonalityError.toExponential(2)}`);
                    
                    if (orthogonalityError < 1e-10) {
                        log("Matrix is nearly orthogonal - excellent!", '#00ff00');
                    } else if (orthogonalityError < 1e-6) {
                        log("Matrix has good orthogonality", '#ffff00');
                    } else {
                        log("Matrix orthogonality could be improved", '#ff6b6b');
                    }
                } catch (orthError) {
                    log("Could not compute orthogonality check", '#ff6b6b');
                }
                let stabilityGrade, stabilityClass;
                if (conditionNumber < 2) {
                    stabilityGrade = "A+";
                    stabilityClass = "grade-a";
                } else if (conditionNumber < 5) {
                    stabilityGrade = "A";
                    stabilityClass = "grade-a";
                } else if (conditionNumber < 10) {
                    stabilityGrade = "B";
                    stabilityClass = "grade-b";
                } else if (conditionNumber < 100) {
                    stabilityGrade = "C";
                    stabilityClass = "grade-c";
                } else if (conditionNumber < 1000) {
                    stabilityGrade = "D";
                    stabilityClass = "grade-d";
                } else {
                    stabilityGrade = "F";
                    stabilityClass = "grade-f";
                }
                
                updateStatus('conditionNumber', conditionNumber.toExponential(2));
                updateStatus('stabilityGrade', stabilityGrade, stabilityClass);
                
                visualizeMatrix(matrix);
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Phase 3: Solve the system
                log("");
                log("PHASE 3: Solving Interpolation System", '#ffd93d');
                log("-".repeat(50));
                
                // Build target Möbius vector
                const mobiusVector = [];
                for (let n = 1; n <= systemSize; n++) {
                    mobiusVector.push(moebius(n));
                }
                
                log(`Target vector: [${mobiusVector.slice(0, 10).join(', ')}...]`);
                
                // Solve using improved method
                const solution = solveSystemImproved(matrix, mobiusVector);
                
                // Ensure solution is a proper array
                if (!Array.isArray(solution)) {
                    throw new Error("Solution is not an array");
                }
                
                log(`Solution computed with ${solution.length} coefficients`);
                
                // Check if solution contains valid numbers
                const validSolution = solution.every(x => typeof x === 'number' && !isNaN(x));
                if (!validSolution) {
                    throw new Error("Solution contains invalid values");
                }
                
                const solutionNorm = Math.sqrt(solution.reduce((s, x) => s + x*x, 0));
                log(`Solution norm: ${solutionNorm.toFixed(6)}`);
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Phase 4: Compute reconstruction and errors
                log("");
                log("PHASE 4: Quality Assessment", '#ffd93d');
                log("-".repeat(50));
                
                const reconstruction = matrix.map(row => 
                    row.reduce((sum, val, j) => sum + val * solution[j], 0)
                );
                
                const errors = reconstruction.map((val, i) => val - mobiusVector[i]);
                const maxError = Math.max(...errors.map(Math.abs));
                const rmsError = Math.sqrt(errors.reduce((sum, e) => sum + e*e, 0) / errors.length);
                
                log(`Max error: ${maxError.toExponential(2)}`);
                log(`RMS error: ${rmsError.toExponential(2)}`);
                
                let qualityGrade, qualityClass;
                if (maxError < 1e-10) {
                    qualityGrade = "A+";
                    qualityClass = "grade-a";
                } else if (maxError < 1e-8) {
                    qualityGrade = "A";
                    qualityClass = "grade-a";
                } else if (maxError < 1e-6) {
                    qualityGrade = "B";
                    qualityClass = "grade-b";
                } else if (maxError < 1e-4) {
                    qualityGrade = "C";
                    qualityClass = "grade-c";
                } else if (maxError < 1e-2) {
                    qualityGrade = "D";
                    qualityClass = "grade-d";
                } else {
                    qualityGrade = "F";
                    qualityClass = "grade-f";
                }
                
                updateStatus('maxError', maxError.toExponential(2));
                updateStatus('qualityGrade', qualityGrade, qualityClass);
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Phase 5: Validation
                log("");
                log("PHASE 5: Validation Tests", '#ffd93d');
                log("-".repeat(50));
                
                const testValues = [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
                let perfectCount = 0;
                let excellentCount = 0;
                
                log("Sample interpolation test:");
                log("n      λ*(n)     μ(n)    error      quality");
                log("-".repeat(55));
                
                for (const n of testValues) {
                    if (n <= systemSize) {
                        const lambdaN = reconstruction[n-1];
                        const muN = moebius(n);
                        const error = Math.abs(lambdaN - muN);
                        
                        let qualityMark;
                        if (error < 1e-10) {
                            qualityMark = "Perfect";
                            perfectCount++;
                        } else if (error < 1e-8) {
                            qualityMark = "Excellent";
                            excellentCount++;
                        } else if (error < 1e-6) {
                            qualityMark = "Very Good";
                        } else if (error < 1e-4) {
                            qualityMark = "Good";
                        } else if (error < 1e-2) {
                            qualityMark = "Fair";
                        } else {
                            qualityMark = "Poor";
                        }
                        
                        log(`${n.toString().padStart(4)} ${lambdaN.toFixed(6).padStart(10)} ${muN.toString().padStart(4)} ${error.toExponential(2).padStart(10)} ${qualityMark}`);
                    }
                }
                
                const totalTested = testValues.filter(n => n <= systemSize).length;
                const successRate = ((perfectCount + excellentCount) / totalTested) * 100;
                
                log(`Success rate: ${successRate.toFixed(1)}%`);
                
                // Update displays
                updateStatus('basisSize', systemSize);
                updateStatus('coverage', `${(systemSize/targetDim*100).toFixed(1)}%`);
                
                // Store results for visualization
                computationState.results = {
                    errors: errors,
                    mobius: mobiusVector,
                    interpolation: reconstruction,
                    conditionHistory: [conditionNumber],
                    basisSizes: {
                        holomorphic: Math.floor(systemSize * 0.4),
                        eisenstein: Math.floor(systemSize * 0.1),
                        continuum: Math.floor(systemSize * 0.5)
                    },
                    maxError: maxError,
                    qualityGrade: qualityGrade,
                    stabilityGrade: stabilityGrade,
                    successRate: successRate
                };
                
                updateCharts(computationState.results);
                
                // Final summary
                log("");
                log("================================================================================", '#64ffda');
                log("IMPLEMENTATION COMPLETE!", '#64ffda');
                log("================================================================================", '#64ffda');
                log("");
                
                log("FINAL RESULTS:");
                log(`* System size: ${systemSize} × ${systemSize}`);
                log(`* Condition number: ${conditionNumber.toExponential(2)}`);
                log(`* Stability grade: ${stabilityGrade}`, stabilityClass === 'grade-a' ? '#00ff00' : stabilityClass === 'grade-b' ? '#ffff00' : '#ff6b6b');
                log(`* Max error: ${maxError.toExponential(2)}`);
                log(`* Quality grade: ${qualityGrade}`, qualityClass === 'grade-a' ? '#00ff00' : qualityClass === 'grade-b' ? '#ffff00' : '#ff6b6b');
                log(`* Success rate: ${successRate.toFixed(1)}%`);
                
                if (conditionNumber < 1e4 && maxError < 1e-6) {
                    log("");
                    log("SUCCESS: High-quality interpolation achieved!", '#00ff00');
                    log("The method demonstrates effective Möbius interpolation", '#00ff00');
                } else if (conditionNumber < 1e6 && maxError < 1e-4) {
                    log("");
                    log("PARTIAL SUCCESS: Reasonable interpolation quality", '#ffff00');
                    log("Further optimization could improve results", '#ffff00');
                }
                
                document.getElementById('exportBtn').disabled = false;
                
            } catch (error) {
                log(`Error during computation: ${error.message}`, '#ff0000');
                console.error(error);
            } finally {
                computationState.running = false;
                document.getElementById('runBtn').disabled = false;
            }
        }
        
        // Improved solver for well-conditioned square systems
        function solveSystemImproved(matrix, target) {
            const n = matrix.length;
            
            try {
                // For well-conditioned matrices, use simple Gaussian elimination
                const A = math.matrix(matrix);
                const b = math.matrix(target);
                
                // Direct solution using math.js
                const solution = math.lusolve(A, b);
                
                // Convert matrix result to array
                const solutionArray = [];
                for (let i = 0; i < n; i++) {
                    solutionArray.push(solution.get([i, 0]));
                }
                return solutionArray;
                
            } catch (error) {
                // Fallback to manual Gaussian elimination
                try {
                    const augmented = matrix.map((row, i) => [...row, target[i]]);
                    
                    // Forward elimination with partial pivoting
                    for (let i = 0; i < n; i++) {
                        // Find pivot
                        let maxRow = i;
                        for (let k = i + 1; k < n; k++) {
                            if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                                maxRow = k;
                            }
                        }
                        
                        // Swap rows
                        if (maxRow !== i) {
                            [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                        }
                        
                        // Check for near-zero pivot
                        if (Math.abs(augmented[i][i]) < 1e-14) {
                            throw new Error("Matrix is singular");
                        }
                        
                        // Eliminate column
                        for (let k = i + 1; k < n; k++) {
                            const factor = augmented[k][i] / augmented[i][i];
                            for (let j = i; j <= n; j++) {
                                augmented[k][j] -= factor * augmented[i][j];
                            }
                        }
                    }
                    
                    // Back substitution
                    const solution = new Array(n);
                    for (let i = n - 1; i >= 0; i--) {
                        solution[i] = augmented[i][n];
                        for (let j = i + 1; j < n; j++) {
                            solution[i] -= augmented[i][j] * solution[j];
                        }
                        solution[i] /= augmented[i][i];
                    }
                    
                    return solution;
                    
                } catch (error2) {
                    console.warn("All solvers failed, returning zero solution");
                    return new Array(n).fill(0);
                }
            }
        }
        
        function resetComputation() {
            computationState.running = false;
            computationState.autoScaling = false;
            computationState.results = null;
            
            clearConsole();
            
            // Reset status displays
            updateStatus('basisSize', '0');
            updateStatus('coverage', '0%');
            updateStatus('conditionNumber', '-');
            updateStatus('maxError', '-');
            updateStatus('stabilityGrade', '-');
            updateStatus('qualityGrade', '-');
            
            // Clear charts
            Object.values(computationState.charts).forEach(chart => {
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.data = [];
                    });
                    if (chart.data.labels) {
                        chart.data.labels = [];
                    }
                    chart.update();
                }
            });
            
            // Clear visualizations
            document.getElementById('matrixViz').innerHTML = '';
            document.getElementById('eisensteinCoeffs').innerHTML = '';
            document.getElementById('scalingResults').style.display = 'none';
            
            // Reset buttons
            document.getElementById('runBtn').disabled = false;
            document.getElementById('autoScaleBtn').disabled = false;
            document.getElementById('autoScaleBtn').textContent = 'Auto Scale Test';
            document.getElementById('autoScaleBtn').classList.remove('auto-scale-running');
            document.getElementById('exportBtn').disabled = true;
            
            log("System reset complete", '#64ffda');
        }
        
        function exportResults() {
            if (!computationState.results) {
                alert('No results to export. Please run the computation first.');
                return;
            }
            
            const results = computationState.results;
            const exportData = {
                timestamp: new Date().toISOString(),
                parameters: {
                    q: 1009,
                    targetDimensions: 1008,
                    windowSize: results.mobius.length
                },
                basisComposition: results.basisSizes,
                qualityMetrics: {
                    maxError: results.maxError,
                    conditionNumber: results.conditionHistory[0],
                    stabilityGrade: results.stabilityGrade,
                    qualityGrade: results.qualityGrade,
                    successRate: results.successRate
                },
                sampleData: {
                    mobiusValues: results.mobius.slice(0, 50),
                    interpolationValues: results.interpolation.slice(0, 50),
                    errors: results.errors.slice(0, 50)
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `automorphic_forms_results_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log("Results exported successfully", '#00ff00');
        }
        
        // Initialize on page load
        window.onload = function() {
            initializeCharts();
            initializeSliders();
            
            // Set initial coverage display
            const initialSize = 200;
            const initialCoverage = (initialSize / 1008 * 100).toFixed(1);
            document.getElementById('systemSizeValue').textContent = `${initialSize} (${initialCoverage}%)`;
            
            log("True Automorphic Forms system initialized", '#64ffda');
            log("Adjust sliders to control system parameters", '#b0b0b0');
            log("System size slider now goes up to φ(1009) = 1008 for full coverage!", '#00ff00');
            log("Click 'Run Computation' to start interpolation", '#b0b0b0');
            log("Click 'Auto Scale Test' to analyze scaling behavior", '#b0b0b0');
        };
    </script>
</body>
</html>