<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Calculator Suite - Waffle Ware</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background-color: #1a1a2e;
            color: #ffffff;
        }
        
        /* Override Tailwind text colors to ensure visibility */
        .text-gray-800, .text-gray-700, .text-gray-600, .text-gray-500, .text-gray-900 {
            color: #000000 !important;
        }
        
        /* Ensure input and form elements have proper colors */
        input, select, textarea, button {
            color: #000000 !important;
        }
        
        /* Make sure backgrounds are appropriate for black text */
        .bg-white, .bg-gray-50, .bg-gray-100, .bg-gray-200 {
            background-color: #ffffff !important;
            color: #000000 !important;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-size: 18px;
            color: #00bfff;
        }
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid #3a3a3a;
            border-radius: 10px;
            padding: 10px 20px;
            color: #00bfff;
            text-decoration: none;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        .back-button:hover {
            background: rgba(58, 58, 58, 0.9);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-button">‚Üê Back to Portfolio</a>
    <div id="root">
        <div class="loading">Loading Physics Calculator Suite...</div>
    </div>
    
    <script type="text/babel">
        const { useState } = React;
        
        // Simple icon components
        const Calculator = () => React.createElement('span', null, 'üßÆ');
        const Users = () => React.createElement('span', null, 'üë•');
        const Rocket = () => React.createElement('span', null, 'üöÄ');
        const Clock = () => React.createElement('span', null, '‚è∞');
        const Info = () => React.createElement('span', null, '‚ÑπÔ∏è');
        const Ruler = () => React.createElement('span', null, 'üìè');
        const Zap = () => React.createElement('span', null, '‚ö°');

const SpecialRelativityCalculators = () => {
  const [activeTab, setActiveTab] = useState('twin');

  return (
    <div className="max-w-4xl mx-auto p-6 bg-white">
      <div className="text-center mb-8">
        <h1 className="text-3xl font-bold text-gray-800 mb-2 flex items-center justify-center gap-2">
          <Calculator className="w-8 h-8" />
          Special Relativity Calculators
        </h1>
        <p className="text-gray-600">
          Solve Einstein's special relativity problems with any combination of known variables
        </p>
      </div>

      {/* Tab Navigation */}
      <div className="flex flex-wrap border-b border-gray-200 mb-6 gap-1">
        <button
          onClick={() => setActiveTab('twin')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'twin'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Users className="w-3 h-3" />
            Twin Paradox
          </div>
        </button>
        <button
          onClick={() => setActiveTab('length')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'length'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Ruler className="w-3 h-3" />
            Length Contract
          </div>
        </button>
        <button
          onClick={() => setActiveTab('lorentz')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'lorentz'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Zap className="w-3 h-3" />
            Lorentz Transform
          </div>
        </button>
        <button
          onClick={() => setActiveTab('velocity')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'velocity'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Rocket className="w-3 h-3" />
            Velocity Add
          </div>
        </button>
        <button
          onClick={() => setActiveTab('energy')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'energy'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Zap className="w-3 h-3" />
            Rel Energy
          </div>
        </button>
        <button
          onClick={() => setActiveTab('blackbody')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'blackbody'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Users className="w-3 h-3" />
            Blackbody
          </div>
        </button>
        <button
          onClick={() => setActiveTab('photoelectric')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'photoelectric'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Zap className="w-3 h-3" />
            Photoelectric
          </div>
        </button>
        <button
          onClick={() => setActiveTab('bohr')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'bohr'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Users className="w-3 h-3" />
            Bohr Model
          </div>
        </button>
        <button
          onClick={() => setActiveTab('squarewell')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'squarewell'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Ruler className="w-3 h-3" />
            Square Well
          </div>
        </button>
        <button
          onClick={() => setActiveTab('debroglie')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'debroglie'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Clock className="w-3 h-3" />
            de Broglie
          </div>
        </button>
        <button
          onClick={() => setActiveTab('uncertainty')}
          className={`px-3 py-2 font-medium text-xs border-b-2 transition-colors ${
            activeTab === 'uncertainty'
              ? 'border-blue-500 text-blue-600'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          <div className="flex items-center gap-1">
            <Info className="w-3 h-3" />
            Uncertainty
          </div>
        </button>
      </div>

      {/* Tab Content */}
      {activeTab === 'twin' && <TwinParadoxCalculator />}
      {activeTab === 'length' && <LengthContractionCalculator />}
      {activeTab === 'lorentz' && <LorentzTransformCalculator />}
      {activeTab === 'velocity' && <VelocityAdditionCalculator />}
      {activeTab === 'energy' && <RelativisticEnergyCalculator />}
      {activeTab === 'blackbody' && <BlackbodyRadiationCalculator />}
      {activeTab === 'photoelectric' && <PhotoelectricEffectCalculator />}
      {activeTab === 'bohr' && <BohrModelCalculator />}
      {activeTab === 'squarewell' && <InfiniteSquareWellCalculator />}
      {activeTab === 'debroglie' && <DeBroglieWavelengthCalculator />}
      {activeTab === 'uncertainty' && <UncertaintyPrincipleCalculator />}
    </div>
  );
};

const UncertaintyPrincipleCalculator = () => {
  const [variables, setVariables] = useState({
    positionUncertainty: { value: '', unit: 'nm', isGiven: false },
    momentumUncertainty: { value: '', unit: 'kg_m_s', isGiven: false },
    velocityUncertainty: { value: '', unit: 'm_s', isGiven: false },
    energyUncertainty: { value: '', unit: 'eV', isGiven: false },
    timeUncertainty: { value: '', unit: 's', isGiven: false },
    particleMass: { value: '', unit: 'kg', isGiven: false },
    particleType: 'electron'
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Physical constants
  const constants = {
    h: 6.626e-34, // Planck constant (J¬∑s)
    hbar: 1.055e-34, // Reduced Planck constant (J¬∑s)
    eV_to_J: 1.60e-19 // eV to Joule conversion
  };

  // Particle presets
  const particles = {
    electron: {
      mass: 9.11e-31, // kg
      name: 'Electron'
    },
    proton: {
      mass: 1.67e-27, // kg
      name: 'Proton'
    },
    neutron: {
      mass: 1.67e-27, // kg
      name: 'Neutron'
    },
    muon: {
      mass: 1.88e-28, // kg
      name: 'Muon'
    },
    custom: {
      mass: 0,
      name: 'Custom'
    }
  };

  const unitOptions = {
    position: [
      { value: 'nm', label: 'Nanometers' },
      { value: 'pm', label: 'Picometers' },
      { value: '√Ö', label: 'Angstroms' },
      { value: 'fm', label: 'Femtometers' },
      { value: 'Œºm', label: 'Micrometers' },
      { value: 'm', label: 'Meters' }
    ],
    momentum: [
      { value: 'kg_m_s', label: 'kg‚ãÖm/s' },
      { value: 'eV_c', label: 'eV/c' },
      { value: 'keV_c', label: 'keV/c' },
      { value: 'MeV_c', label: 'MeV/c' }
    ],
    velocity: [
      { value: 'm_s', label: 'm/s' },
      { value: 'km_s', label: 'km/s' },
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c' }
    ],
    energy: [
      { value: 'eV', label: 'Electron volts' },
      { value: 'meV', label: 'Millielectron volts' },
      { value: 'keV', label: 'Kiloelectron volts' },
      { value: 'J', label: 'Joules' },
      { value: 'MeV', label: 'Megaelectron volts' }
    ],
    time: [
      { value: 's', label: 'Seconds' },
      { value: 'ms', label: 'Milliseconds' },
      { value: 'Œºs', label: 'Microseconds' },
      { value: 'ns', label: 'Nanoseconds' },
      { value: 'ps', label: 'Picoseconds' },
      { value: 'fs', label: 'Femtoseconds' }
    ],
    mass: [
      { value: 'kg', label: 'Kilograms' },
      { value: 'g', label: 'Grams' },
      { value: 'u', label: 'Atomic mass units' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    const c = 3.00e8; // speed of light
    
    if (type === 'position') {
      switch (unit) {
        case 'm': return val;
        case 'Œºm': return val * 1e-6;
        case 'nm': return val * 1e-9;
        case 'pm': return val * 1e-12;
        case 'fm': return val * 1e-15;
        case '√Ö': return val * 1e-10;
        default: return val;
      }
    } else if (type === 'momentum') {
      switch (unit) {
        case 'kg_m_s': return val;
        case 'eV_c': return (val * constants.eV_to_J) / c;
        case 'keV_c': return (val * constants.eV_to_J * 1e3) / c;
        case 'MeV_c': return (val * constants.eV_to_J * 1e6) / c;
        default: return val;
      }
    } else if (type === 'velocity') {
      switch (unit) {
        case 'm_s': return val;
        case 'km_s': return val * 1e3;
        case 'fraction_c': return val * c;
        case 'percent_c': return (val / 100) * c;
        default: return val;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return val;
        case 'eV': return val * constants.eV_to_J;
        case 'meV': return val * constants.eV_to_J * 1e-3;
        case 'keV': return val * constants.eV_to_J * 1e3;
        case 'MeV': return val * constants.eV_to_J * 1e6;
        default: return val;
      }
    } else if (type === 'time') {
      switch (unit) {
        case 's': return val;
        case 'ms': return val * 1e-3;
        case 'Œºs': return val * 1e-6;
        case 'ns': return val * 1e-9;
        case 'ps': return val * 1e-12;
        case 'fs': return val * 1e-15;
        default: return val;
      }
    } else if (type === 'mass') {
      switch (unit) {
        case 'kg': return val;
        case 'g': return val * 1e-3;
        case 'u': return val * 1.66e-27; // atomic mass unit
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    const c = 3.00e8; // speed of light
    
    if (type === 'position') {
      switch (unit) {
        case 'm': return value;
        case 'Œºm': return value / 1e-6;
        case 'nm': return value / 1e-9;
        case 'pm': return value / 1e-12;
        case 'fm': return value / 1e-15;
        case '√Ö': return value / 1e-10;
        default: return value;
      }
    } else if (type === 'momentum') {
      switch (unit) {
        case 'kg_m_s': return value;
        case 'eV_c': return (value * c) / constants.eV_to_J;
        case 'keV_c': return (value * c) / (constants.eV_to_J * 1e3);
        case 'MeV_c': return (value * c) / (constants.eV_to_J * 1e6);
        default: return value;
      }
    } else if (type === 'velocity') {
      switch (unit) {
        case 'm_s': return value;
        case 'km_s': return value / 1e3;
        case 'fraction_c': return value / c;
        case 'percent_c': return (value / c) * 100;
        default: return value;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return value;
        case 'eV': return value / constants.eV_to_J;
        case 'meV': return value / (constants.eV_to_J * 1e-3);
        case 'keV': return value / (constants.eV_to_J * 1e3);
        case 'MeV': return value / (constants.eV_to_J * 1e6);
        default: return value;
      }
    } else if (type === 'time') {
      switch (unit) {
        case 's': return value;
        case 'ms': return value / 1e-3;
        case 'Œºs': return value / 1e-6;
        case 'ns': return value / 1e-9;
        case 'ps': return value / 1e-12;
        case 'fs': return value / 1e-15;
        default: return value;
      }
    } else if (type === 'mass') {
      switch (unit) {
        case 'kg': return value;
        case 'g': return value / 1e-3;
        case 'u': return value / 1.66e-27;
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => 
      variables[key].isGiven && key !== 'particleType'
    );
    
    if (givenVars.length < 1) {
      setError('Please select at least 1 variable as given.');
      return;
    }

    try {
      let solution = {};
      let Œîx, Œîp, Œîv, ŒîE, Œît, m;

      // Get particle mass
      if (variables.particleType !== 'custom') {
        m = particles[variables.particleType].mass;
        if (!variables.particleMass.isGiven) {
          solution.particleMass = m;
        }
      } else if (variables.particleMass.isGiven) {
        m = convertToBaseUnits(variables.particleMass.value, variables.particleMass.unit, 'mass');
      } else {
        throw new Error('Custom particle requires mass to be specified');
      }

      // Convert given values to base units
      const givenValues = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        let type = 'position';
        if (key === 'momentumUncertainty') type = 'momentum';
        if (key === 'velocityUncertainty') type = 'velocity';
        if (key === 'energyUncertainty') type = 'energy';
        if (key === 'timeUncertainty') type = 'time';
        if (key === 'particleMass') type = 'mass';
        
        givenValues[key] = convertToBaseUnits(variable.value, variable.unit, type);
      });

      // Heisenberg uncertainty principles:
      // Œîx √ó Œîp ‚â• h/2 (position-momentum) - using Planck constant h, not ‚Ñè
      // ŒîE √ó Œît ‚â• ‚Ñè/2 (energy-time) - this one typically uses ‚Ñè
      // Œîp = mŒîv (momentum-velocity relation)

      // For minimum uncertainty, use equality: Œîx √ó Œîp = h/2

      // Position-momentum uncertainty calculations
      if (variables.positionUncertainty.isGiven && !variables.momentumUncertainty.isGiven && !variables.velocityUncertainty.isGiven) {
        // Calculate minimum momentum and velocity uncertainty from position
        Œîx = givenValues.positionUncertainty;
        Œîp = constants.h / (2 * Œîx); // minimum uncertainty using h/2
        Œîv = Œîp / m;
        
        solution.momentumUncertainty = Œîp;
        solution.velocityUncertainty = Œîv;
        
      } else if (variables.momentumUncertainty.isGiven && !variables.positionUncertainty.isGiven) {
        // Calculate minimum position uncertainty from momentum
        Œîp = givenValues.momentumUncertainty;
        Œîx = constants.h / (2 * Œîp); // minimum uncertainty using h/2
        Œîv = Œîp / m;
        
        solution.positionUncertainty = Œîx;
        solution.velocityUncertainty = Œîv;
        
      } else if (variables.velocityUncertainty.isGiven && !variables.positionUncertainty.isGiven && !variables.momentumUncertainty.isGiven) {
        // Calculate minimum position uncertainty from velocity
        Œîv = givenValues.velocityUncertainty;
        Œîp = m * Œîv;
        Œîx = constants.h / (2 * Œîp); // minimum uncertainty using h/2
        
        solution.positionUncertainty = Œîx;
        solution.momentumUncertainty = Œîp;
        
      } else if (variables.positionUncertainty.isGiven && variables.momentumUncertainty.isGiven) {
        // Check if given values satisfy uncertainty principle
        Œîx = givenValues.positionUncertainty;
        Œîp = givenValues.momentumUncertainty;
        
        const product = Œîx * Œîp;
        const minimum = constants.h / 2; // using h/2 for position-momentum
        if (product < minimum) {
          throw new Error(`Uncertainty product (${product.toExponential(2)}) is less than minimum allowed (${minimum.toExponential(2)})`);
        }
        
        Œîv = Œîp / m;
        solution.velocityUncertainty = Œîv;
        
      } else if (variables.positionUncertainty.isGiven && variables.velocityUncertainty.isGiven) {
        // Check if given values satisfy uncertainty principle
        Œîx = givenValues.positionUncertainty;
        Œîv = givenValues.velocityUncertainty;
        Œîp = m * Œîv;
        
        const product = Œîx * Œîp;
        const minimum = constants.h / 2; // using h/2 for position-momentum
        if (product < minimum) {
          throw new Error(`Uncertainty product violates Heisenberg principle`);
        }
        
        solution.momentumUncertainty = Œîp;
      }

      // Energy-time uncertainty calculations
      if (variables.energyUncertainty.isGiven && variables.timeUncertainty.isGiven) {
        ŒîE = givenValues.energyUncertainty;
        Œît = givenValues.timeUncertainty;
        
        const product = ŒîE * Œît;
        const minimum = constants.hbar / 2;
        if (product < minimum) {
          throw new Error(`Energy-time uncertainty product violates Heisenberg principle`);
        }
        
      } else if (variables.energyUncertainty.isGiven && !variables.timeUncertainty.isGiven) {
        ŒîE = givenValues.energyUncertainty;
        Œît = constants.hbar / (2 * ŒîE); // minimum uncertainty
        solution.timeUncertainty = Œît;
        
      } else if (variables.timeUncertainty.isGiven && !variables.energyUncertainty.isGiven) {
        Œît = givenValues.timeUncertainty;
        ŒîE = constants.hbar / (2 * Œît); // minimum uncertainty
        solution.energyUncertainty = ŒîE;
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key] && !variables[key].isGiven) {
          const variable = variables[key];
          let type = 'position';
          if (key === 'momentumUncertainty') type = 'momentum';
          if (key === 'velocityUncertainty') type = 'velocity';
          if (key === 'energyUncertainty') type = 'energy';
          if (key === 'timeUncertainty') type = 'time';
          if (key === 'particleMass') type = 'mass';
          
          const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
          
          displayResults[key] = {
            value: convertedValue,
            unit: variable.unit
          };
          
          // Format numbers appropriately
          const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
            ? convertedValue.toExponential(3)
            : convertedValue.toFixed(6).replace(/\.?0+$/, '');
          
          updatedVariables[key] = {
            ...updatedVariables[key],
            value: formattedValue
          };
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    if (key === 'particleType') return;
    
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const updateParticleType = (particleType) => {
    setVariables(prev => ({
      ...prev,
      particleType,
      particleMass: {
        ...prev.particleMass,
        isGiven: particleType === 'custom' ? prev.particleMass.isGiven : false
      }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'positionUncertainty') return unitOptions.position;
    if (key === 'momentumUncertainty') return unitOptions.momentum;
    if (key === 'velocityUncertainty') return unitOptions.velocity;
    if (key === 'energyUncertainty') return unitOptions.energy;
    if (key === 'timeUncertainty') return unitOptions.time;
    if (key === 'particleMass') return unitOptions.mass;
    return [];
  };

  const reset = () => {
    setVariables({
      positionUncertainty: { value: '', unit: 'nm', isGiven: false },
      momentumUncertainty: { value: '', unit: 'kg_m_s', isGiven: false },
      velocityUncertainty: { value: '', unit: 'm_s', isGiven: false },
      energyUncertainty: { value: '', unit: 'eV', isGiven: false },
      timeUncertainty: { value: '', unit: 's', isGiven: false },
      particleMass: { value: '', unit: 'kg', isGiven: false },
      particleType: 'electron'
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    positionUncertainty: 'Position Uncertainty (Œîx)',
    momentumUncertainty: 'Momentum Uncertainty (Œîp)',
    velocityUncertainty: 'Velocity Uncertainty (Œîv)',
    energyUncertainty: 'Energy Uncertainty (ŒîE)',
    timeUncertainty: 'Time Uncertainty (Œît)',
    particleMass: 'Particle Mass (m)'
  };

  const variableIcons = {
    positionUncertainty: <Ruler className="w-4 h-4" />,
    momentumUncertainty: <Rocket className="w-4 h-4" />,
    velocityUncertainty: <Rocket className="w-4 h-4" />,
    energyUncertainty: <Zap className="w-4 h-4" />,
    timeUncertainty: <Clock className="w-4 h-4" />,
    particleMass: <Users className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => 
    variables[key].isGiven && key !== 'particleType'
  ).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using Heisenberg's uncertainty principle.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Electron confined to 0.220 nm. What's the minimum velocity uncertainty?
            </p>
          </div>
        </div>
      </div>

      {/* Particle Type Selection */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <label className="text-sm font-medium text-gray-700 mb-3 block">Particle Type:</label>
        <div className="flex gap-4 flex-wrap">
          {Object.keys(particles).map(type => (
            <button
              key={type}
              onClick={() => updateParticleType(type)}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                variables.particleType === type
                  ? 'bg-blue-100 text-blue-800 border border-blue-300'
                  : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
              }`}
            >
              {particles[type].name}
            </button>
          ))}
        </div>
        {variables.particleType !== 'custom' && (
          <p className="text-xs text-gray-500 mt-2">
            {particles[variables.particleType].name}: m = {particles[variables.particleType].mass.toExponential(2)} kg
          </p>
        )}
      </div>

      {/* Formula Display */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <h4 className="text-sm font-medium text-gray-700 mb-2">Heisenberg Uncertainty Principle:</h4>
        <div className="text-sm text-gray-600 space-y-1">
          <p><strong>Position-momentum:</strong> Œîx √ó Œîp ‚â• h/2</p>
          <p><strong>Energy-time:</strong> ŒîE √ó Œît ‚â• ‚Ñè/2</p>
          <p><strong>Momentum-velocity:</strong> Œîp = mŒîv</p>
          <p><strong>Minimum uncertainty:</strong> Œîx √ó Œîp = h/2</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).filter(key => key !== 'particleType').map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={key === 'particleMass' && variables.particleType !== 'custom'}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : (key === 'particleMass' && variables.particleType !== 'custom')
                    ? 'bg-gray-200 text-gray-500 border border-gray-300 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              {getUnitOptions(key).length > 0 && (
                <select
                  value={variables[key].unit}
                  onChange={(e) => updateUnit(key, e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  {getUnitOptions(key).map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              )}
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 1}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 1
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Uncertainty Principle
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables using Heisenberg's uncertainty principle
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          Heisenberg's uncertainty principle states that certain pairs of physical properties cannot be measured simultaneously with arbitrary precision. 
          The position-momentum uncertainty Œîx √ó Œîp ‚â• h/2 means that localizing a particle increases its momentum uncertainty. 
          For minimum uncertainty, the equality holds: Œîx √ó Œîp = h/2. The energy-time uncertainty uses ŒîE √ó Œît ‚â• ‚Ñè/2.
        </p>
      </div>
    </div>
  );
};

const DeBroglieWavelengthCalculator = () => {
  const [variables, setVariables] = useState({
    wavelength: { value: '', unit: 'nm', isGiven: false },
    momentum: { value: '', unit: 'kg_m_s', isGiven: false },
    velocity: { value: '', unit: 'm_s', isGiven: false },
    kineticEnergy: { value: '', unit: 'eV', isGiven: false },
    potentialDifference: { value: '', unit: 'V', isGiven: false },
    particleMass: { value: '', unit: 'kg', isGiven: false },
    particleCharge: { value: '', unit: 'C', isGiven: false },
    particleType: 'electron'
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Physical constants
  const constants = {
    h: 6.626e-34, // Planck constant (J¬∑s)
    c: 3.00e8, // speed of light (m/s)
    eV_to_J: 1.60e-19 // eV to Joule conversion
  };

  // Particle presets
  const particles = {
    electron: {
      mass: 9.11e-31, // kg
      charge: -1.60e-19, // C
      name: 'Electron'
    },
    proton: {
      mass: 1.67e-27, // kg
      charge: 1.60e-19, // C
      name: 'Proton'
    },
    neutron: {
      mass: 1.67e-27, // kg
      charge: 0, // C
      name: 'Neutron'
    },
    alpha: {
      mass: 6.64e-27, // kg (helium nucleus)
      charge: 3.20e-19, // C (2e)
      name: 'Alpha Particle'
    },
    custom: {
      mass: 0,
      charge: 0,
      name: 'Custom'
    }
  };

  const unitOptions = {
    wavelength: [
      { value: 'nm', label: 'Nanometers' },
      { value: 'Œºm', label: 'Micrometers' },
      { value: 'pm', label: 'Picometers' },
      { value: '√Ö', label: 'Angstroms' },
      { value: 'm', label: 'Meters' },
      { value: 'mm', label: 'Millimeters' }
    ],
    momentum: [
      { value: 'kg_m_s', label: 'kg‚ãÖm/s' },
      { value: 'eV_c', label: 'eV/c' },
      { value: 'MeV_c', label: 'MeV/c' },
      { value: 'keV_c', label: 'keV/c' }
    ],
    velocity: [
      { value: 'm_s', label: 'm/s' },
      { value: 'km_s', label: 'km/s' },
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c' }
    ],
    energy: [
      { value: 'eV', label: 'Electron volts' },
      { value: 'meV', label: 'Millielectron volts' },
      { value: 'keV', label: 'Kiloelectron volts' },
      { value: 'J', label: 'Joules' }
    ],
    voltage: [
      { value: 'V', label: 'Volts' },
      { value: 'mV', label: 'Millivolts' },
      { value: 'kV', label: 'Kilovolts' },
      { value: 'MV', label: 'Megavolts' }
    ],
    mass: [
      { value: 'kg', label: 'Kilograms' },
      { value: 'g', label: 'Grams' },
      { value: 'u', label: 'Atomic mass units' }
    ],
    charge: [
      { value: 'C', label: 'Coulombs' },
      { value: 'e', label: 'Elementary charges' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'wavelength') {
      switch (unit) {
        case 'm': return val;
        case 'mm': return val * 1e-3;
        case 'Œºm': return val * 1e-6;
        case 'nm': return val * 1e-9;
        case 'pm': return val * 1e-12;
        case '√Ö': return val * 1e-10;
        default: return val;
      }
    } else if (type === 'momentum') {
      switch (unit) {
        case 'kg_m_s': return val;
        case 'eV_c': return (val * constants.eV_to_J) / constants.c;
        case 'keV_c': return (val * constants.eV_to_J * 1e3) / constants.c;
        case 'MeV_c': return (val * constants.eV_to_J * 1e6) / constants.c;
        default: return val;
      }
    } else if (type === 'velocity') {
      switch (unit) {
        case 'm_s': return val;
        case 'km_s': return val * 1e3;
        case 'fraction_c': return val * constants.c;
        case 'percent_c': return (val / 100) * constants.c;
        default: return val;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return val;
        case 'eV': return val * constants.eV_to_J;
        case 'meV': return val * constants.eV_to_J * 1e-3;
        case 'keV': return val * constants.eV_to_J * 1e3;
        default: return val;
      }
    } else if (type === 'voltage') {
      switch (unit) {
        case 'V': return val;
        case 'mV': return val * 1e-3;
        case 'kV': return val * 1e3;
        case 'MV': return val * 1e6;
        default: return val;
      }
    } else if (type === 'mass') {
      switch (unit) {
        case 'kg': return val;
        case 'g': return val * 1e-3;
        case 'u': return val * 1.66e-27; // atomic mass unit
        default: return val;
      }
    } else if (type === 'charge') {
      switch (unit) {
        case 'C': return val;
        case 'e': return val * 1.60e-19; // elementary charge
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'wavelength') {
      switch (unit) {
        case 'm': return value;
        case 'mm': return value / 1e-3;
        case 'Œºm': return value / 1e-6;
        case 'nm': return value / 1e-9;
        case 'pm': return value / 1e-12;
        case '√Ö': return value / 1e-10;
        default: return value;
      }
    } else if (type === 'momentum') {
      switch (unit) {
        case 'kg_m_s': return value;
        case 'eV_c': return (value * constants.c) / constants.eV_to_J;
        case 'keV_c': return (value * constants.c) / (constants.eV_to_J * 1e3);
        case 'MeV_c': return (value * constants.c) / (constants.eV_to_J * 1e6);
        default: return value;
      }
    } else if (type === 'velocity') {
      switch (unit) {
        case 'm_s': return value;
        case 'km_s': return value / 1e3;
        case 'fraction_c': return value / constants.c;
        case 'percent_c': return (value / constants.c) * 100;
        default: return value;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return value;
        case 'eV': return value / constants.eV_to_J;
        case 'meV': return value / (constants.eV_to_J * 1e-3);
        case 'keV': return value / (constants.eV_to_J * 1e3);
        default: return value;
      }
    } else if (type === 'voltage') {
      switch (unit) {
        case 'V': return value;
        case 'mV': return value / 1e-3;
        case 'kV': return value / 1e3;
        case 'MV': return value / 1e6;
        default: return value;
      }
    } else if (type === 'mass') {
      switch (unit) {
        case 'kg': return value;
        case 'g': return value / 1e-3;
        case 'u': return value / 1.66e-27;
        default: return value;
      }
    } else if (type === 'charge') {
      switch (unit) {
        case 'C': return value;
        case 'e': return value / 1.60e-19;
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => 
      variables[key].isGiven && key !== 'particleType'
    );
    
    if (givenVars.length < 1) {
      setError('Please select at least 1 variable as given.');
      return;
    }

    try {
      let solution = {};
      let Œª, p, v, KE, V, m, q;

      // Get particle properties
      if (variables.particleType !== 'custom') {
        const particle = particles[variables.particleType];
        m = particle.mass;
        q = particle.charge;
        if (!variables.particleMass.isGiven) solution.particleMass = m;
        if (!variables.particleCharge.isGiven) solution.particleCharge = q;
      } else {
        if (variables.particleMass.isGiven) {
          m = convertToBaseUnits(variables.particleMass.value, variables.particleMass.unit, 'mass');
        } else {
          throw new Error('Custom particle requires mass to be specified');
        }
        if (variables.particleCharge.isGiven) {
          q = convertToBaseUnits(variables.particleCharge.value, variables.particleCharge.unit, 'charge');
        } else {
          q = 0; // neutral particle by default
          solution.particleCharge = q;
        }
      }

      // Convert given values to base units
      const givenValues = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        let type = 'wavelength';
        if (key === 'momentum') type = 'momentum';
        if (key === 'velocity') type = 'velocity';
        if (key === 'kineticEnergy') type = 'energy';
        if (key === 'potentialDifference') type = 'voltage';
        if (key === 'particleMass') type = 'mass';
        if (key === 'particleCharge') type = 'charge';
        
        givenValues[key] = convertToBaseUnits(variable.value, variable.unit, type);
      });

      // Core relationships:
      // Œª = h/p (de Broglie wavelength)
      // p = mv (momentum)
      // KE = p¬≤/(2m) = ¬Ωmv¬≤ (kinetic energy)
      // KE = qV (for charged particles accelerated through potential)

      // Start with what we have and calculate the rest
      if (variables.wavelength.isGiven) {
        Œª = givenValues.wavelength;
        p = constants.h / Œª; // de Broglie relation
        v = p / m; // momentum relation
        KE = (p * p) / (2 * m); // kinetic energy
        if (Math.abs(q) > 1e-20) { // if particle is charged
          V = KE / Math.abs(q); // potential difference
          solution.potentialDifference = V;
        }
        
        solution.momentum = p;
        solution.velocity = v;
        solution.kineticEnergy = KE;
        
      } else if (variables.momentum.isGiven) {
        p = givenValues.momentum;
        Œª = constants.h / p;
        v = p / m;
        KE = (p * p) / (2 * m);
        if (Math.abs(q) > 1e-20) {
          V = KE / Math.abs(q);
          solution.potentialDifference = V;
        }
        
        solution.wavelength = Œª;
        solution.velocity = v;
        solution.kineticEnergy = KE;
        
      } else if (variables.velocity.isGiven) {
        v = givenValues.velocity;
        p = m * v;
        Œª = constants.h / p;
        KE = 0.5 * m * v * v;
        if (Math.abs(q) > 1e-20) {
          V = KE / Math.abs(q);
          solution.potentialDifference = V;
        }
        
        solution.wavelength = Œª;
        solution.momentum = p;
        solution.kineticEnergy = KE;
        
      } else if (variables.kineticEnergy.isGiven) {
        KE = givenValues.kineticEnergy;
        p = Math.sqrt(2 * m * KE);
        Œª = constants.h / p;
        v = p / m;
        if (Math.abs(q) > 1e-20) {
          V = KE / Math.abs(q);
          solution.potentialDifference = V;
        }
        
        solution.wavelength = Œª;
        solution.momentum = p;
        solution.velocity = v;
        
      } else if (variables.potentialDifference.isGiven) {
        if (Math.abs(q) < 1e-20) {
          throw new Error('Neutral particles cannot be accelerated by electric potential');
        }
        V = givenValues.potentialDifference;
        KE = Math.abs(q) * V; // kinetic energy gained
        p = Math.sqrt(2 * m * KE);
        Œª = constants.h / p;
        v = p / m;
        
        solution.wavelength = Œª;
        solution.momentum = p;
        solution.velocity = v;
        solution.kineticEnergy = KE;
      }

      // Validate results for nonrelativistic regime
      if (v && v > 0.1 * constants.c) {
        setError(`Warning: Velocity is ${(v/constants.c*100).toFixed(1)}% of c. Relativistic effects should be considered.`);
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key] && !variables[key].isGiven) {
          const variable = variables[key];
          let type = 'wavelength';
          if (key === 'momentum') type = 'momentum';
          if (key === 'velocity') type = 'velocity';
          if (key === 'kineticEnergy') type = 'energy';
          if (key === 'potentialDifference') type = 'voltage';
          if (key === 'particleMass') type = 'mass';
          if (key === 'particleCharge') type = 'charge';
          
          const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
          
          displayResults[key] = {
            value: convertedValue,
            unit: variable.unit
          };
          
          // Format numbers appropriately
          const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
            ? convertedValue.toExponential(3)
            : convertedValue.toFixed(6).replace(/\.?0+$/, '');
          
          updatedVariables[key] = {
            ...updatedVariables[key],
            value: formattedValue
          };
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      if (!error) setError(''); // Only clear error if no validation warnings

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    if (key === 'particleType') return;
    
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const updateParticleType = (particleType) => {
    setVariables(prev => ({
      ...prev,
      particleType,
      // Reset mass and charge if switching to/from custom
      particleMass: {
        ...prev.particleMass,
        isGiven: particleType === 'custom' ? prev.particleMass.isGiven : false
      },
      particleCharge: {
        ...prev.particleCharge,
        isGiven: particleType === 'custom' ? prev.particleCharge.isGiven : false
      }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'wavelength') return unitOptions.wavelength;
    if (key === 'momentum') return unitOptions.momentum;
    if (key === 'velocity') return unitOptions.velocity;
    if (key === 'kineticEnergy') return unitOptions.energy;
    if (key === 'potentialDifference') return unitOptions.voltage;
    if (key === 'particleMass') return unitOptions.mass;
    if (key === 'particleCharge') return unitOptions.charge;
    return [];
  };

  const reset = () => {
    setVariables({
      wavelength: { value: '', unit: 'nm', isGiven: false },
      momentum: { value: '', unit: 'kg_m_s', isGiven: false },
      velocity: { value: '', unit: 'm_s', isGiven: false },
      kineticEnergy: { value: '', unit: 'eV', isGiven: false },
      potentialDifference: { value: '', unit: 'V', isGiven: false },
      particleMass: { value: '', unit: 'kg', isGiven: false },
      particleCharge: { value: '', unit: 'C', isGiven: false },
      particleType: 'electron'
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    wavelength: 'de Broglie Wavelength (Œª)',
    momentum: 'Momentum (p)',
    velocity: 'Velocity (v)',
    kineticEnergy: 'Kinetic Energy (KE)',
    potentialDifference: 'Potential Difference (V)',
    particleMass: 'Particle Mass (m)',
    particleCharge: 'Particle Charge (q)'
  };

  const variableIcons = {
    wavelength: <Ruler className="w-4 h-4" />,
    momentum: <Rocket className="w-4 h-4" />,
    velocity: <Rocket className="w-4 h-4" />,
    kineticEnergy: <Zap className="w-4 h-4" />,
    potentialDifference: <Zap className="w-4 h-4" />,
    particleMass: <Users className="w-4 h-4" />,
    particleCharge: <Users className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => 
    variables[key].isGiven && key !== 'particleType'
  ).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using de Broglie wavelength relationships.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Electron accelerated to Œª = 880 nm. What potential difference was used?
            </p>
          </div>
        </div>
      </div>

      {/* Particle Type Selection */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <label className="text-sm font-medium text-gray-700 mb-3 block">Particle Type:</label>
        <div className="flex gap-4 flex-wrap">
          {Object.keys(particles).map(type => (
            <button
              key={type}
              onClick={() => updateParticleType(type)}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                variables.particleType === type
                  ? 'bg-blue-100 text-blue-800 border border-blue-300'
                  : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
              }`}
            >
              {particles[type].name}
            </button>
          ))}
        </div>
        {variables.particleType !== 'custom' && (
          <p className="text-xs text-gray-500 mt-2">
            {particles[variables.particleType].name}: m = {particles[variables.particleType].mass.toExponential(2)} kg, 
            q = {particles[variables.particleType].charge.toExponential(2)} C
          </p>
        )}
      </div>

      {/* Formula Display */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <h4 className="text-sm font-medium text-gray-700 mb-2">de Broglie Wavelength Formulas:</h4>
        <div className="text-sm text-gray-600 space-y-1">
          <p><strong>de Broglie relation:</strong> Œª = h/p</p>
          <p><strong>Momentum:</strong> p = mv</p>
          <p><strong>Kinetic energy:</strong> KE = p¬≤/(2m) = ¬Ωmv¬≤</p>
          <p><strong>For charged particles:</strong> KE = qV ‚Üí Œª = h/‚àö(2mqV)</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).filter(key => key !== 'particleType').map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={(key === 'particleMass' || key === 'particleCharge') && variables.particleType !== 'custom'}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : ((key === 'particleMass' || key === 'particleCharge') && variables.particleType !== 'custom')
                    ? 'bg-gray-200 text-gray-500 border border-gray-300 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              {getUnitOptions(key).length > 0 && (
                <select
                  value={variables[key].unit}
                  onChange={(e) => updateUnit(key, e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  {getUnitOptions(key).map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              )}
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 1}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 1
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate de Broglie Wavelength
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className={`border rounded-lg p-4 mb-6 ${
          error.includes('Warning') 
            ? 'bg-yellow-50 border-yellow-200' 
            : 'bg-red-50 border-red-200'
        }`}>
          <p className={`text-sm ${
            error.includes('Warning') 
              ? 'text-yellow-700' 
              : 'text-red-700'
          }`}>{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables using de Broglie wavelength relationships
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          The de Broglie wavelength Œª = h/p shows the wave nature of matter. For particles accelerated through electric potential, 
          KE = qV gives kinetic energy, leading to Œª = h/‚àö(2mqV). This calculator assumes nonrelativistic motion (v ‚â™ c). 
          For charged particles, the potential difference V accelerates them from rest to the final velocity.
        </p>
      </div>
    </div>
  );
};

const InfiniteSquareWellCalculator = () => {
  const [variables, setVariables] = useState({
    boxWidth: { value: '', unit: 'nm', isGiven: false },
    quantumNumber: { value: '', unit: '', isGiven: false },
    particleMass: { value: '', unit: 'kg', isGiven: false },
    energyLevel: { value: '', unit: 'eV', isGiven: false },
    wavelength: { value: '', unit: 'nm', isGiven: false },
    momentum: { value: '', unit: 'kg_m_s', isGiven: false },
    particleType: 'electron'
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Physical constants
  const constants = {
    h: 6.626e-34, // Planck constant (J¬∑s)
    hbar: 1.055e-34, // Reduced Planck constant (J¬∑s)
    eV_to_J: 1.60e-19, // eV to Joule conversion
    c: 3.00e8 // speed of light (m/s)
  };

  // Particle presets
  const particles = {
    electron: {
      mass: 9.11e-31, // kg
      name: 'Electron'
    },
    proton: {
      mass: 1.67e-27, // kg
      name: 'Proton'
    },
    neutron: {
      mass: 1.67e-27, // kg
      name: 'Neutron'
    },
    custom: {
      mass: 0,
      name: 'Custom'
    }
  };

  const unitOptions = {
    length: [
      { value: 'nm', label: 'Nanometers' },
      { value: 'Œºm', label: 'Micrometers' },
      { value: 'pm', label: 'Picometers' },
      { value: '√Ö', label: 'Angstroms' },
      { value: 'm', label: 'Meters' },
      { value: 'mm', label: 'Millimeters' }
    ],
    mass: [
      { value: 'kg', label: 'Kilograms' },
      { value: 'g', label: 'Grams' },
      { value: 'u', label: 'Atomic mass units' }
    ],
    energy: [
      { value: 'eV', label: 'Electron volts' },
      { value: 'meV', label: 'Millielectron volts' },
      { value: 'J', label: 'Joules' },
      { value: 'keV', label: 'Kiloelectron volts' }
    ],
    momentum: [
      { value: 'kg_m_s', label: 'kg‚ãÖm/s' },
      { value: 'eV_c', label: 'eV/c' },
      { value: 'MeV_c', label: 'MeV/c' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'length') {
      switch (unit) {
        case 'm': return val;
        case 'mm': return val * 1e-3;
        case 'Œºm': return val * 1e-6;
        case 'nm': return val * 1e-9;
        case 'pm': return val * 1e-12;
        case '√Ö': return val * 1e-10;
        default: return val;
      }
    } else if (type === 'mass') {
      switch (unit) {
        case 'kg': return val;
        case 'g': return val * 1e-3;
        case 'u': return val * 1.66e-27; // atomic mass unit
        default: return val;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return val;
        case 'eV': return val * constants.eV_to_J;
        case 'meV': return val * constants.eV_to_J * 1e-3;
        case 'keV': return val * constants.eV_to_J * 1e3;
        default: return val;
      }
    } else if (type === 'momentum') {
      switch (unit) {
        case 'kg_m_s': return val;
        case 'eV_c': return (val * constants.eV_to_J) / constants.c;
        case 'MeV_c': return (val * constants.eV_to_J * 1e6) / constants.c;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'length') {
      switch (unit) {
        case 'm': return value;
        case 'mm': return value / 1e-3;
        case 'Œºm': return value / 1e-6;
        case 'nm': return value / 1e-9;
        case 'pm': return value / 1e-12;
        case '√Ö': return value / 1e-10;
        default: return value;
      }
    } else if (type === 'mass') {
      switch (unit) {
        case 'kg': return value;
        case 'g': return value / 1e-3;
        case 'u': return value / 1.66e-27;
        default: return value;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return value;
        case 'eV': return value / constants.eV_to_J;
        case 'meV': return value / (constants.eV_to_J * 1e-3);
        case 'keV': return value / (constants.eV_to_J * 1e3);
        default: return value;
      }
    } else if (type === 'momentum') {
      switch (unit) {
        case 'kg_m_s': return value;
        case 'eV_c': return (value * constants.c) / constants.eV_to_J;
        case 'MeV_c': return (value * constants.c) / (constants.eV_to_J * 1e6);
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => 
      variables[key].isGiven && key !== 'particleType'
    );
    
    if (givenVars.length < 2) {
      setError('Please select at least 2 variables as given.');
      return;
    }

    try {
      let solution = {};
      let L, n, m, E, wavelength, momentum;

      // Get particle mass
      if (variables.particleType !== 'custom') {
        m = particles[variables.particleType].mass;
        if (!variables.particleMass.isGiven) {
          solution.particleMass = m;
        }
      } else if (variables.particleMass.isGiven) {
        m = convertToBaseUnits(variables.particleMass.value, variables.particleMass.unit, 'mass');
      } else {
        throw new Error('Custom particle requires mass to be specified');
      }

      // Convert given values to base units
      const givenValues = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        if (key === 'quantumNumber') {
          givenValues[key] = parseInt(variable.value);
        } else {
          let type = 'length';
          if (key === 'particleMass') type = 'mass';
          if (key === 'energyLevel') type = 'energy';
          if (key === 'wavelength') type = 'length';
          if (key === 'momentum') type = 'momentum';
          
          givenValues[key] = convertToBaseUnits(variable.value, variable.unit, type);
        }
      });

      // Main formula: E_n = (n¬≤œÄ¬≤‚Ñè¬≤)/(2mL¬≤)
      // Also: p = nœÄ‚Ñè/L and Œª = 2L/n

      if (variables.boxWidth.isGiven && variables.quantumNumber.isGiven) {
        L = givenValues.boxWidth;
        n = givenValues.quantumNumber;
        
        if (n < 1 || !Number.isInteger(n)) {
          throw new Error('Quantum number must be a positive integer');
        }
        
        // Calculate energy
        E = (n * n * Math.PI * Math.PI * constants.hbar * constants.hbar) / (2 * m * L * L);
        
        // Calculate momentum
        momentum = (n * Math.PI * constants.hbar) / L;
        
        // Calculate wavelength (de Broglie wavelength)
        wavelength = (2 * L) / n;
        
        solution.energyLevel = E;
        solution.momentum = momentum;
        solution.wavelength = wavelength;
        
      } else if (variables.boxWidth.isGiven && variables.energyLevel.isGiven) {
        L = givenValues.boxWidth;
        E = givenValues.energyLevel;
        
        // Solve for quantum number: n = sqrt(2mEL¬≤/(œÄ¬≤‚Ñè¬≤))
        const n_squared = (2 * m * E * L * L) / (Math.PI * Math.PI * constants.hbar * constants.hbar);
        n = Math.sqrt(n_squared);
        
        if (!Number.isInteger(Math.round(n)) || Math.round(n) < 1) {
          throw new Error('Energy does not correspond to a valid quantum state');
        }
        
        n = Math.round(n);
        momentum = (n * Math.PI * constants.hbar) / L;
        wavelength = (2 * L) / n;
        
        solution.quantumNumber = n;
        solution.momentum = momentum;
        solution.wavelength = wavelength;
        
      } else if (variables.quantumNumber.isGiven && variables.energyLevel.isGiven) {
        n = givenValues.quantumNumber;
        E = givenValues.energyLevel;
        
        if (n < 1 || !Number.isInteger(n)) {
          throw new Error('Quantum number must be a positive integer');
        }
        
        // Solve for box width: L = sqrt(n¬≤œÄ¬≤‚Ñè¬≤/(2mE))
        L = Math.sqrt((n * n * Math.PI * Math.PI * constants.hbar * constants.hbar) / (2 * m * E));
        
        momentum = (n * Math.PI * constants.hbar) / L;
        wavelength = (2 * L) / n;
        
        solution.boxWidth = L;
        solution.momentum = momentum;
        solution.wavelength = wavelength;
        
      } else if (variables.boxWidth.isGiven && variables.wavelength.isGiven) {
        L = givenValues.boxWidth;
        wavelength = givenValues.wavelength;
        
        // From Œª = 2L/n, solve for n
        n = (2 * L) / wavelength;
        
        if (!Number.isInteger(Math.round(n)) || Math.round(n) < 1) {
          throw new Error('Wavelength does not correspond to a valid quantum state');
        }
        
        n = Math.round(n);
        E = (n * n * Math.PI * Math.PI * constants.hbar * constants.hbar) / (2 * m * L * L);
        momentum = (n * Math.PI * constants.hbar) / L;
        
        solution.quantumNumber = n;
        solution.energyLevel = E;
        solution.momentum = momentum;
        
      } else if (variables.boxWidth.isGiven && variables.momentum.isGiven) {
        L = givenValues.boxWidth;
        momentum = givenValues.momentum;
        
        // From p = nœÄ‚Ñè/L, solve for n
        n = (momentum * L) / (Math.PI * constants.hbar);
        
        if (!Number.isInteger(Math.round(n)) || Math.round(n) < 1) {
          throw new Error('Momentum does not correspond to a valid quantum state');
        }
        
        n = Math.round(n);
        E = (n * n * Math.PI * Math.PI * constants.hbar * constants.hbar) / (2 * m * L * L);
        wavelength = (2 * L) / n;
        
        solution.quantumNumber = n;
        solution.energyLevel = E;
        solution.wavelength = wavelength;
        
      } else {
        throw new Error('Please provide box width and one other parameter, or quantum number and energy');
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key] && !variables[key].isGiven) {
          const variable = variables[key];
          
          if (key === 'quantumNumber') {
            updatedVariables[key] = {
              ...updatedVariables[key],
              value: solution[key].toString()
            };
            displayResults[key] = {
              value: solution[key],
              unit: ''
            };
          } else {
            let type = 'length';
            if (key === 'particleMass') type = 'mass';
            if (key === 'energyLevel') type = 'energy';
            if (key === 'momentum') type = 'momentum';
            
            const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
            
            displayResults[key] = {
              value: convertedValue,
              unit: variable.unit
            };
            
            // Format numbers appropriately
            const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
              ? convertedValue.toExponential(3)
              : convertedValue.toFixed(6).replace(/\.?0+$/, '');
            
            updatedVariables[key] = {
              ...updatedVariables[key],
              value: formattedValue
            };
          }
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    if (key === 'particleType') return;
    
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const updateParticleType = (particleType) => {
    setVariables(prev => ({
      ...prev,
      particleType,
      // Reset mass if switching to/from custom
      particleMass: {
        ...prev.particleMass,
        isGiven: particleType === 'custom' ? prev.particleMass.isGiven : false
      }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'boxWidth' || key === 'wavelength') return unitOptions.length;
    if (key === 'particleMass') return unitOptions.mass;
    if (key === 'energyLevel') return unitOptions.energy;
    if (key === 'momentum') return unitOptions.momentum;
    if (key === 'quantumNumber') return [];
    return [];
  };

  const reset = () => {
    setVariables({
      boxWidth: { value: '', unit: 'nm', isGiven: false },
      quantumNumber: { value: '', unit: '', isGiven: false },
      particleMass: { value: '', unit: 'kg', isGiven: false },
      energyLevel: { value: '', unit: 'eV', isGiven: false },
      wavelength: { value: '', unit: 'nm', isGiven: false },
      momentum: { value: '', unit: 'kg_m_s', isGiven: false },
      particleType: 'electron'
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    boxWidth: 'Box Width (L)',
    quantumNumber: 'Quantum Number (n)',
    particleMass: 'Particle Mass (m)',
    energyLevel: 'Energy Level (E‚Çô)',
    wavelength: 'de Broglie Wavelength (Œª)',
    momentum: 'Momentum (p)'
  };

  const variableIcons = {
    boxWidth: <Ruler className="w-4 h-4" />,
    quantumNumber: <Users className="w-4 h-4" />,
    particleMass: <Rocket className="w-4 h-4" />,
    energyLevel: <Zap className="w-4 h-4" />,
    wavelength: <Ruler className="w-4 h-4" />,
    momentum: <Rocket className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => 
    variables[key].isGiven && key !== 'particleType'
  ).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using the infinite square well (particle in a box) model.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Electron in 7.3 nm box. What's the ground state energy?
            </p>
          </div>
        </div>
      </div>

      {/* Particle Type Selection */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <label className="text-sm font-medium text-gray-700 mb-3 block">Particle Type:</label>
        <div className="flex gap-4 flex-wrap">
          {Object.keys(particles).map(type => (
            <button
              key={type}
              onClick={() => updateParticleType(type)}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                variables.particleType === type
                  ? 'bg-blue-100 text-blue-800 border border-blue-300'
                  : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
              }`}
            >
              {particles[type].name}
            </button>
          ))}
        </div>
        {variables.particleType !== 'custom' && (
          <p className="text-xs text-gray-500 mt-2">
            {particles[variables.particleType].name}: m = {particles[variables.particleType].mass.toExponential(2)} kg
          </p>
        )}
      </div>

      {/* Formula Display */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <h4 className="text-sm font-medium text-gray-700 mb-2">Infinite Square Well Formulas:</h4>
        <div className="text-sm text-gray-600 space-y-1">
          <p><strong>Energy levels:</strong> E‚Çô = n¬≤œÄ¬≤‚Ñè¬≤/(2mL¬≤)</p>
          <p><strong>Momentum:</strong> p = nœÄ‚Ñè/L</p>
          <p><strong>Wavelength:</strong> Œª = 2L/n</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).filter(key => key !== 'particleType').map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={key === 'particleMass' && variables.particleType !== 'custom'}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : (key === 'particleMass' && variables.particleType !== 'custom')
                    ? 'bg-gray-200 text-gray-500 border border-gray-300 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type={key === 'quantumNumber' ? "number" : "number"}
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step={key === 'quantumNumber' ? "1" : "any"}
                  min={key === 'quantumNumber' ? "1" : undefined}
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              {getUnitOptions(key).length > 0 && (
                <select
                  value={variables[key].unit}
                  onChange={(e) => updateUnit(key, e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  {getUnitOptions(key).map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              )}
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 2}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 2
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Square Well
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables using the infinite square well model
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          The infinite square well (particle in a box) has quantized energy levels E‚Çô = n¬≤œÄ¬≤‚Ñè¬≤/(2mL¬≤) where n = 1, 2, 3, ... 
          The ground state (n=1) has the lowest possible energy. The particle's momentum is quantized as p = nœÄ‚Ñè/L, 
          and its de Broglie wavelength is Œª = 2L/n, fitting exactly n/2 wavelengths in the box.
        </p>
      </div>
    </div>
  );
};

const BohrModelCalculator = () => {
  const [variables, setVariables] = useState({
    initialQuantumNumber: { value: '', unit: '', isGiven: false },
    finalQuantumNumber: { value: '', unit: '', isGiven: false },
    groundStateEnergy: { value: '-13.6', unit: 'eV', isGiven: true },
    initialEnergy: { value: '', unit: 'eV', isGiven: false },
    finalEnergy: { value: '', unit: 'eV', isGiven: false },
    photonEnergy: { value: '', unit: 'eV', isGiven: false },
    photonWavelength: { value: '', unit: 'nm', isGiven: false },
    photonFrequency: { value: '', unit: 'THz', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Physical constants
  const constants = {
    c: 3.00e8, // speed of light (m/s)
    h_J: 6.626e-34, // Planck constant (J¬∑s)
    h_eV: 4.141e-15, // Planck constant (eV¬∑s)
    eV_to_J: 1.60e-19 // eV to Joule conversion
  };

  const unitOptions = {
    energy: [
      { value: 'eV', label: 'Electron volts' },
      { value: 'J', label: 'Joules' },
      { value: 'keV', label: 'Kiloelectron volts' },
      { value: 'meV', label: 'Millielectron volts' }
    ],
    wavelength: [
      { value: 'nm', label: 'Nanometers' },
      { value: 'Œºm', label: 'Micrometers' },
      { value: '√Ö', label: 'Angstroms' },
      { value: 'm', label: 'Meters' },
      { value: 'pm', label: 'Picometers' }
    ],
    frequency: [
      { value: 'Hz', label: 'Hertz' },
      { value: 'THz', label: 'Terahertz' },
      { value: 'PHz', label: 'Petahertz' },
      { value: 'GHz', label: 'Gigahertz' },
      { value: 'MHz', label: 'Megahertz' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'energy') {
      switch (unit) {
        case 'eV': return val * constants.eV_to_J;
        case 'J': return val;
        case 'keV': return val * constants.eV_to_J * 1000;
        case 'meV': return val * constants.eV_to_J * 0.001;
        default: return val;
      }
    } else if (type === 'wavelength') {
      switch (unit) {
        case 'm': return val;
        case 'Œºm': return val * 1e-6;
        case 'nm': return val * 1e-9;
        case 'pm': return val * 1e-12;
        case '√Ö': return val * 1e-10;
        default: return val;
      }
    } else if (type === 'frequency') {
      switch (unit) {
        case 'Hz': return val;
        case 'MHz': return val * 1e6;
        case 'GHz': return val * 1e9;
        case 'THz': return val * 1e12;
        case 'PHz': return val * 1e15;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'energy') {
      switch (unit) {
        case 'eV': return value / constants.eV_to_J;
        case 'J': return value;
        case 'keV': return value / (constants.eV_to_J * 1000);
        case 'meV': return value / (constants.eV_to_J * 0.001);
        default: return value;
      }
    } else if (type === 'wavelength') {
      switch (unit) {
        case 'm': return value;
        case 'Œºm': return value / 1e-6;
        case 'nm': return value / 1e-9;
        case 'pm': return value / 1e-12;
        case '√Ö': return value / 1e-10;
        default: return value;
      }
    } else if (type === 'frequency') {
      switch (unit) {
        case 'Hz': return value;
        case 'MHz': return value / 1e6;
        case 'GHz': return value / 1e9;
        case 'THz': return value / 1e12;
        case 'PHz': return value / 1e15;
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length < 1) {
      setError('Please select at least 1 variable as given.');
      return;
    }

    try {
      let solution = {};
      let n_i, n_f, E_ground, E_i, E_f, photonEnergy, wavelength, frequency;

      // Convert given values to base units
      const givenValues = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        if (key === 'initialQuantumNumber' || key === 'finalQuantumNumber') {
          givenValues[key] = parseInt(variable.value);
        } else {
          let type = 'energy';
          if (key === 'photonWavelength') type = 'wavelength';
          if (key === 'photonFrequency') type = 'frequency';
          givenValues[key] = convertToBaseUnits(variable.value, variable.unit, type);
        }
      });

      // Get ground state energy (always given by default)
      E_ground = givenValues.groundStateEnergy;

      // Calculate energy levels using Bohr model: E_n = E_ground / n¬≤
      if (variables.initialQuantumNumber.isGiven) {
        n_i = givenValues.initialQuantumNumber;
        if (n_i < 1 || !Number.isInteger(n_i)) {
          throw new Error('Quantum numbers must be positive integers');
        }
        E_i = E_ground / (n_i * n_i);
        solution.initialEnergy = E_i;
      }

      if (variables.finalQuantumNumber.isGiven) {
        n_f = givenValues.finalQuantumNumber;
        if (n_f < 1 || !Number.isInteger(n_f)) {
          throw new Error('Quantum numbers must be positive integers');
        }
        E_f = E_ground / (n_f * n_f);
        solution.finalEnergy = E_f;
      }

      // Calculate photon properties from energy levels
      if (E_i !== undefined && E_f !== undefined) {
        photonEnergy = Math.abs(E_f - E_i); // Energy difference
        frequency = photonEnergy / constants.h_J;
        wavelength = constants.c / frequency;
        
        solution.photonEnergy = photonEnergy;
        solution.photonFrequency = frequency;
        solution.photonWavelength = wavelength;
      }

      // Handle cases where photon properties are given
      if (variables.photonEnergy.isGiven) {
        photonEnergy = givenValues.photonEnergy;
        frequency = photonEnergy / constants.h_J;
        wavelength = constants.c / frequency;
        
        solution.photonFrequency = frequency;
        solution.photonWavelength = wavelength;
        
        // If one energy level is known, calculate the other
        if (E_i !== undefined) {
          // Two possibilities: absorption (E_f = E_i + photonEnergy) or emission (E_f = E_i - photonEnergy)
          // Use the one that gives a valid quantum number
          const E_f_absorption = E_i + photonEnergy;
          const E_f_emission = E_i - photonEnergy;
          
          const n_f_absorption = Math.sqrt(E_ground / E_f_absorption);
          const n_f_emission = Math.sqrt(E_ground / E_f_emission);
          
          if (Number.isInteger(Math.round(n_f_absorption)) && Math.round(n_f_absorption) > 0) {
            n_f = Math.round(n_f_absorption);
            E_f = E_f_absorption;
          } else if (Number.isInteger(Math.round(n_f_emission)) && Math.round(n_f_emission) > 0) {
            n_f = Math.round(n_f_emission);
            E_f = E_f_emission;
          } else {
            throw new Error('Photon energy does not correspond to a valid transition');
          }
          
          solution.finalQuantumNumber = n_f;
          solution.finalEnergy = E_f;
        } else if (E_f !== undefined) {
          // Calculate initial energy level
          const E_i_absorption = E_f - photonEnergy;
          const E_i_emission = E_f + photonEnergy;
          
          const n_i_absorption = Math.sqrt(E_ground / E_i_absorption);
          const n_i_emission = Math.sqrt(E_ground / E_i_emission);
          
          if (Number.isInteger(Math.round(n_i_absorption)) && Math.round(n_i_absorption) > 0) {
            n_i = Math.round(n_i_absorption);
            E_i = E_i_absorption;
          } else if (Number.isInteger(Math.round(n_i_emission)) && Math.round(n_i_emission) > 0) {
            n_i = Math.round(n_i_emission);
            E_i = E_i_emission;
          } else {
            throw new Error('Photon energy does not correspond to a valid transition');
          }
          
          solution.initialQuantumNumber = n_i;
          solution.initialEnergy = E_i;
        }
      }

      if (variables.photonWavelength.isGiven) {
        wavelength = givenValues.photonWavelength;
        frequency = constants.c / wavelength;
        photonEnergy = constants.h_J * frequency;
        
        solution.photonEnergy = photonEnergy;
        solution.photonFrequency = frequency;
      }

      if (variables.photonFrequency.isGiven) {
        frequency = givenValues.photonFrequency;
        wavelength = constants.c / frequency;
        photonEnergy = constants.h_J * frequency;
        
        solution.photonEnergy = photonEnergy;
        solution.photonWavelength = wavelength;
      }

      // Calculate missing quantum numbers from energy levels
      if (variables.initialEnergy.isGiven && !variables.initialQuantumNumber.isGiven) {
        E_i = givenValues.initialEnergy;
        n_i = Math.sqrt(E_ground / E_i);
        if (!Number.isInteger(Math.round(n_i)) || Math.round(n_i) < 1) {
          throw new Error('Energy level does not correspond to a valid quantum number');
        }
        solution.initialQuantumNumber = Math.round(n_i);
      }

      if (variables.finalEnergy.isGiven && !variables.finalQuantumNumber.isGiven) {
        E_f = givenValues.finalEnergy;
        n_f = Math.sqrt(E_ground / E_f);
        if (!Number.isInteger(Math.round(n_f)) || Math.round(n_f) < 1) {
          throw new Error('Energy level does not correspond to a valid quantum number');
        }
        solution.finalQuantumNumber = Math.round(n_f);
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key] && !variables[key].isGiven) {
          const variable = variables[key];
          
          if (key === 'initialQuantumNumber' || key === 'finalQuantumNumber') {
            // Quantum numbers are integers
            updatedVariables[key] = {
              ...updatedVariables[key],
              value: solution[key].toString()
            };
            displayResults[key] = {
              value: solution[key],
              unit: ''
            };
          } else {
            let type = 'energy';
            if (key === 'photonWavelength') type = 'wavelength';
            if (key === 'photonFrequency') type = 'frequency';
            
            const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
            
            displayResults[key] = {
              value: convertedValue,
              unit: variable.unit
            };
            
            // Format numbers appropriately
            const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
              ? convertedValue.toExponential(3)
              : convertedValue.toFixed(6).replace(/\.?0+$/, '');
            
            updatedVariables[key] = {
              ...updatedVariables[key],
              value: formattedValue
            };
          }
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'photonWavelength') return unitOptions.wavelength;
    if (key === 'photonFrequency') return unitOptions.frequency;
    if (key === 'initialQuantumNumber' || key === 'finalQuantumNumber') return [];
    return unitOptions.energy;
  };

  const reset = () => {
    setVariables({
      initialQuantumNumber: { value: '', unit: '', isGiven: false },
      finalQuantumNumber: { value: '', unit: '', isGiven: false },
      groundStateEnergy: { value: '-13.6', unit: 'eV', isGiven: true },
      initialEnergy: { value: '', unit: 'eV', isGiven: false },
      finalEnergy: { value: '', unit: 'eV', isGiven: false },
      photonEnergy: { value: '', unit: 'eV', isGiven: false },
      photonWavelength: { value: '', unit: 'nm', isGiven: false },
      photonFrequency: { value: '', unit: 'THz', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    initialQuantumNumber: 'Initial Quantum Number (n·µ¢)',
    finalQuantumNumber: 'Final Quantum Number (nf)',
    groundStateEnergy: 'Ground State Energy (E‚ÇÅ)',
    initialEnergy: 'Initial Energy Level (E·µ¢)',
    finalEnergy: 'Final Energy Level (Ef)',
    photonEnergy: 'Photon Energy (ŒîE)',
    photonWavelength: 'Photon Wavelength (Œª)',
    photonFrequency: 'Photon Frequency (f)'
  };

  const variableIcons = {
    initialQuantumNumber: <Users className="w-4 h-4" />,
    finalQuantumNumber: <Users className="w-4 h-4" />,
    groundStateEnergy: <Zap className="w-4 h-4" />,
    initialEnergy: <Rocket className="w-4 h-4" />,
    finalEnergy: <Rocket className="w-4 h-4" />,
    photonEnergy: <Zap className="w-4 h-4" />,
    photonWavelength: <Ruler className="w-4 h-4" />,
    photonFrequency: <Clock className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using the Bohr model of hydrogen.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Transition from n=2 to n=3 state. What energy is absorbed?
            </p>
          </div>
        </div>
      </div>

      {/* Constants Display */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <h4 className="text-sm font-medium text-gray-700 mb-2">Bohr Model Formula:</h4>
        <div className="text-sm text-gray-600">
          <p><strong>Energy levels:</strong> E‚Çô = E‚ÇÅ/n¬≤ where E‚ÇÅ = -13.6 eV for hydrogen</p>
          <p><strong>Transitions:</strong> ŒîE = |Ef - E·µ¢| = hf = hc/Œª</p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={key === 'groundStateEnergy'} // Always given by default
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : key === 'groundStateEnergy'
                    ? 'bg-gray-200 text-gray-500 border border-gray-300 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type={key === 'initialQuantumNumber' || key === 'finalQuantumNumber' ? "number" : "number"}
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step={key === 'initialQuantumNumber' || key === 'finalQuantumNumber' ? "1" : "any"}
                  min={key === 'initialQuantumNumber' || key === 'finalQuantumNumber' ? "1" : undefined}
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              {getUnitOptions(key).length > 0 && (
                <select
                  value={variables[key].unit}
                  onChange={(e) => updateUnit(key, e.target.value)}
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  {getUnitOptions(key).map(option => (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  ))}
                </select>
              )}
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 2} // Need at least ground state + 1 more
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 2
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Bohr Model
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables using the Bohr model
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          The Bohr model uses quantized energy levels: E‚Çô = E‚ÇÅ/n¬≤ where E‚ÇÅ = -13.6 eV for hydrogen. 
          Transitions between levels involve photon absorption (n·µ¢ &lt; nf) or emission (n·µ¢ &gt; nf) with energy ŒîE = |Ef - E·µ¢|. 
          The photon energy relates to wavelength and frequency through E = hf = hc/Œª.
        </p>
      </div>
    </div>
  );
};

const PhotoelectricEffectCalculator = () => {
  const [variables, setVariables] = useState({
    wavelength: { value: '', unit: 'nm', isGiven: false },
    frequency: { value: '', unit: 'THz', isGiven: false },
    photonEnergy: { value: '', unit: 'eV', isGiven: false },
    workFunction: { value: '', unit: 'eV', isGiven: false },
    maxKineticEnergy: { value: '', unit: 'eV', isGiven: false },
    stoppingPotential: { value: '', unit: 'V', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Physical constants
  const constants = {
    c: 3.00e8, // speed of light (m/s)
    h_J: 6.626e-34, // Planck constant (J¬∑s)
    h_eV: 4.141e-15, // Planck constant (eV¬∑s)
    eV_to_J: 1.60e-19 // eV to Joule conversion
  };

  const unitOptions = {
    wavelength: [
      { value: 'm', label: 'Meters' },
      { value: 'mm', label: 'Millimeters' },
      { value: 'Œºm', label: 'Micrometers' },
      { value: 'nm', label: 'Nanometers' },
      { value: 'pm', label: 'Picometers' },
      { value: '√Ö', label: 'Angstroms' }
    ],
    frequency: [
      { value: 'Hz', label: 'Hertz' },
      { value: 'kHz', label: 'Kilohertz' },
      { value: 'MHz', label: 'Megahertz' },
      { value: 'GHz', label: 'Gigahertz' },
      { value: 'THz', label: 'Terahertz' },
      { value: 'PHz', label: 'Petahertz' }
    ],
    energy: [
      { value: 'J', label: 'Joules' },
      { value: 'eV', label: 'Electron volts' },
      { value: 'keV', label: 'Kiloelectron volts' },
      { value: 'MeV', label: 'Megaelectron volts' }
    ],
    voltage: [
      { value: 'V', label: 'Volts' },
      { value: 'mV', label: 'Millivolts' },
      { value: 'kV', label: 'Kilovolts' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'wavelength') {
      switch (unit) {
        case 'm': return val;
        case 'mm': return val * 1e-3;
        case 'Œºm': return val * 1e-6;
        case 'nm': return val * 1e-9;
        case 'pm': return val * 1e-12;
        case '√Ö': return val * 1e-10;
        default: return val;
      }
    } else if (type === 'frequency') {
      switch (unit) {
        case 'Hz': return val;
        case 'kHz': return val * 1e3;
        case 'MHz': return val * 1e6;
        case 'GHz': return val * 1e9;
        case 'THz': return val * 1e12;
        case 'PHz': return val * 1e15;
        default: return val;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return val;
        case 'eV': return val * constants.eV_to_J;
        case 'keV': return val * constants.eV_to_J * 1000;
        case 'MeV': return val * constants.eV_to_J * 1000000;
        default: return val;
      }
    } else if (type === 'voltage') {
      switch (unit) {
        case 'V': return val;
        case 'mV': return val * 1e-3;
        case 'kV': return val * 1e3;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'wavelength') {
      switch (unit) {
        case 'm': return value;
        case 'mm': return value / 1e-3;
        case 'Œºm': return value / 1e-6;
        case 'nm': return value / 1e-9;
        case 'pm': return value / 1e-12;
        case '√Ö': return value / 1e-10;
        default: return value;
      }
    } else if (type === 'frequency') {
      switch (unit) {
        case 'Hz': return value;
        case 'kHz': return value / 1e3;
        case 'MHz': return value / 1e6;
        case 'GHz': return value / 1e9;
        case 'THz': return value / 1e12;
        case 'PHz': return value / 1e15;
        default: return value;
      }
    } else if (type === 'energy') {
      switch (unit) {
        case 'J': return value;
        case 'eV': return value / constants.eV_to_J;
        case 'keV': return value / (constants.eV_to_J * 1000);
        case 'MeV': return value / (constants.eV_to_J * 1000000);
        default: return value;
      }
    } else if (type === 'voltage') {
      switch (unit) {
        case 'V': return value;
        case 'mV': return value / 1e-3;
        case 'kV': return value / 1e3;
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length < 1) {
      setError('Please select at least 1 variable as given.');
      return;
    }

    try {
      let solution = {};
      let wavelength, frequency, photonEnergy, workFunction, maxKineticEnergy, stoppingPotential;

      // Convert all given values to base units (SI: meters, Hz, Joules, Volts)
      const givenValues = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        let type = 'energy';
        if (key === 'wavelength') type = 'wavelength';
        if (key === 'frequency') type = 'frequency';
        if (key === 'stoppingPotential') type = 'voltage';
        
        givenValues[key] = convertToBaseUnits(variable.value, variable.unit, type);
      });

      // Calculate photon properties first
      if (variables.wavelength.isGiven) {
        wavelength = givenValues.wavelength;
        frequency = constants.c / wavelength;
        photonEnergy = constants.h_J * frequency;
      } else if (variables.frequency.isGiven) {
        frequency = givenValues.frequency;
        wavelength = constants.c / frequency;
        photonEnergy = constants.h_J * frequency;
      } else if (variables.photonEnergy.isGiven) {
        photonEnergy = givenValues.photonEnergy;
        frequency = photonEnergy / constants.h_J;
        wavelength = constants.c / frequency;
      }

      // Apply Einstein's photoelectric equation: E_photon = œÜ + KE_max
      if (variables.workFunction.isGiven && variables.maxKineticEnergy.isGiven) {
        workFunction = givenValues.workFunction;
        maxKineticEnergy = givenValues.maxKineticEnergy;
        photonEnergy = workFunction + maxKineticEnergy;
        frequency = photonEnergy / constants.h_J;
        wavelength = constants.c / frequency;
        stoppingPotential = maxKineticEnergy / constants.eV_to_J; // Convert J to eV, then to V
      } else if (variables.workFunction.isGiven && photonEnergy) {
        workFunction = givenValues.workFunction;
        maxKineticEnergy = photonEnergy - workFunction;
        if (maxKineticEnergy < 0) {
          throw new Error('Photon energy is less than work function - no photoelectrons emitted');
        }
        stoppingPotential = maxKineticEnergy / constants.eV_to_J;
      } else if (variables.maxKineticEnergy.isGiven && photonEnergy) {
        maxKineticEnergy = givenValues.maxKineticEnergy;
        workFunction = photonEnergy - maxKineticEnergy;
        if (workFunction < 0) {
          throw new Error('Calculated work function is negative - check input values');
        }
        stoppingPotential = maxKineticEnergy / constants.eV_to_J;
      } else if (variables.stoppingPotential.isGiven) {
        stoppingPotential = givenValues.stoppingPotential;
        maxKineticEnergy = stoppingPotential * constants.eV_to_J; // eV_stop = KE_max/e, so KE_max = eV_stop
        if (photonEnergy) {
          workFunction = photonEnergy - maxKineticEnergy;
          if (workFunction < 0) {
            throw new Error('Calculated work function is negative - check input values');
          }
        } else if (variables.workFunction.isGiven) {
          workFunction = givenValues.workFunction;
          photonEnergy = workFunction + maxKineticEnergy;
          frequency = photonEnergy / constants.h_J;
          wavelength = constants.c / frequency;
        }
      }

      // Store solutions (only if not already given)
      if (!variables.wavelength.isGiven && wavelength) solution.wavelength = wavelength;
      if (!variables.frequency.isGiven && frequency) solution.frequency = frequency;
      if (!variables.photonEnergy.isGiven && photonEnergy) solution.photonEnergy = photonEnergy;
      if (!variables.workFunction.isGiven && workFunction) solution.workFunction = workFunction;
      if (!variables.maxKineticEnergy.isGiven && maxKineticEnergy) solution.maxKineticEnergy = maxKineticEnergy;
      if (!variables.stoppingPotential.isGiven && stoppingPotential) solution.stoppingPotential = stoppingPotential;

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key]) {
          const variable = variables[key];
          let type = 'energy';
          if (key === 'wavelength') type = 'wavelength';
          if (key === 'frequency') type = 'frequency';
          if (key === 'stoppingPotential') type = 'voltage';
          
          const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
          
          displayResults[key] = {
            value: convertedValue,
            unit: variable.unit
          };
          
          // Format numbers appropriately
          const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
            ? convertedValue.toExponential(3)
            : convertedValue.toFixed(6).replace(/\.?0+$/, '');
          
          updatedVariables[key] = {
            ...updatedVariables[key],
            value: formattedValue
          };
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'wavelength') return unitOptions.wavelength;
    if (key === 'frequency') return unitOptions.frequency;
    if (key === 'stoppingPotential') return unitOptions.voltage;
    return unitOptions.energy;
  };

  const reset = () => {
    setVariables({
      wavelength: { value: '', unit: 'nm', isGiven: false },
      frequency: { value: '', unit: 'THz', isGiven: false },
      photonEnergy: { value: '', unit: 'eV', isGiven: false },
      workFunction: { value: '', unit: 'eV', isGiven: false },
      maxKineticEnergy: { value: '', unit: 'eV', isGiven: false },
      stoppingPotential: { value: '', unit: 'V', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    wavelength: 'Wavelength (Œª)',
    frequency: 'Frequency (f)',
    photonEnergy: 'Photon Energy (E)',
    workFunction: 'Work Function (œÜ)',
    maxKineticEnergy: 'Max Kinetic Energy (KE_max)',
    stoppingPotential: 'Stopping Potential (V_stop)'
  };

  const variableIcons = {
    wavelength: <Ruler className="w-4 h-4" />,
    frequency: <Users className="w-4 h-4" />,
    photonEnergy: <Zap className="w-4 h-4" />,
    workFunction: <Rocket className="w-4 h-4" />,
    maxKineticEnergy: <Rocket className="w-4 h-4" />,
    stoppingPotential: <Zap className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using Einstein's photoelectric equation.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> 300 nm light hits metal with work function 1.70 eV. What's the max KE of photoelectrons?
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>For threshold frequency:</strong> Set Max Kinetic Energy = 0 eV (photoelectrons just barely escape with no kinetic energy).
            </p>
          </div>
        </div>
      </div>

      {/* Constants Display */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <h4 className="text-sm font-medium text-gray-700 mb-2">Physical Constants Used:</h4>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs text-gray-600">
          <div>c = {constants.c.toExponential(2)} m/s</div>
          <div>h = {constants.h_J.toExponential(3)} J¬∑s</div>
          <div>h = {constants.h_eV.toExponential(3)} eV¬∑s</div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {getUnitOptions(key).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 1}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 1
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Photoelectric Effect
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables using Einstein's photoelectric equation
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses Einstein's photoelectric equation: E_photon = œÜ + KE_max, where E_photon = hf = hc/Œª. 
          The photon must have enough energy to overcome the work function œÜ before any kinetic energy KE_max is given to the photoelectron. 
          The stopping potential V_stop relates to kinetic energy by eV_stop = KE_max.
        </p>
      </div>
    </div>
  );
};

const BlackbodyRadiationCalculator = () => {
  const [variables, setVariables] = useState({
    temperature: { value: '', unit: 'K', isGiven: false },
    peakWavelength: { value: '', unit: 'nm', isGiven: false },
    peakFrequency: { value: '', unit: 'THz', isGiven: false },
    totalPower: { value: '', unit: 'W_m2', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Physical constants
  const constants = {
    c: 3.00e8, // speed of light (m/s)
    wienConstant: 2.90e-3, // Wien displacement law constant (m¬∑K)
    stefanBoltzmann: 5.670e-8 // Stefan-Boltzmann constant (W/m¬≤¬∑K‚Å¥)
  };

  const unitOptions = {
    temperature: [
      { value: 'K', label: 'Kelvin' },
      { value: 'C', label: 'Celsius' },
      { value: 'F', label: 'Fahrenheit' }
    ],
    wavelength: [
      { value: 'm', label: 'Meters' },
      { value: 'mm', label: 'Millimeters' },
      { value: 'Œºm', label: 'Micrometers' },
      { value: 'nm', label: 'Nanometers' },
      { value: 'pm', label: 'Picometers' },
      { value: '√Ö', label: 'Angstroms' }
    ],
    frequency: [
      { value: 'Hz', label: 'Hertz' },
      { value: 'kHz', label: 'Kilohertz' },
      { value: 'MHz', label: 'Megahertz' },
      { value: 'GHz', label: 'Gigahertz' },
      { value: 'THz', label: 'Terahertz' },
      { value: 'PHz', label: 'Petahertz' }
    ],
    power: [
      { value: 'W_m2', label: 'W/m¬≤' },
      { value: 'kW_m2', label: 'kW/m¬≤' },
      { value: 'MW_m2', label: 'MW/m¬≤' },
      { value: 'W_cm2', label: 'W/cm¬≤' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'temperature') {
      switch (unit) {
        case 'K': return val;
        case 'C': return val + 273.15;
        case 'F': return (val - 32) * 5/9 + 273.15;
        default: return val;
      }
    } else if (type === 'wavelength') {
      switch (unit) {
        case 'm': return val;
        case 'mm': return val * 1e-3;
        case 'Œºm': return val * 1e-6;
        case 'nm': return val * 1e-9;
        case 'pm': return val * 1e-12;
        case '√Ö': return val * 1e-10;
        default: return val;
      }
    } else if (type === 'frequency') {
      switch (unit) {
        case 'Hz': return val;
        case 'kHz': return val * 1e3;
        case 'MHz': return val * 1e6;
        case 'GHz': return val * 1e9;
        case 'THz': return val * 1e12;
        case 'PHz': return val * 1e15;
        default: return val;
      }
    } else if (type === 'power') {
      switch (unit) {
        case 'W_m2': return val;
        case 'kW_m2': return val * 1e3;
        case 'MW_m2': return val * 1e6;
        case 'W_cm2': return val * 1e4; // 1 W/cm¬≤ = 10‚Å¥ W/m¬≤
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'temperature') {
      switch (unit) {
        case 'K': return value;
        case 'C': return value - 273.15;
        case 'F': return (value - 273.15) * 9/5 + 32;
        default: return value;
      }
    } else if (type === 'wavelength') {
      switch (unit) {
        case 'm': return value;
        case 'mm': return value / 1e-3;
        case 'Œºm': return value / 1e-6;
        case 'nm': return value / 1e-9;
        case 'pm': return value / 1e-12;
        case '√Ö': return value / 1e-10;
        default: return value;
      }
    } else if (type === 'frequency') {
      switch (unit) {
        case 'Hz': return value;
        case 'kHz': return value / 1e3;
        case 'MHz': return value / 1e6;
        case 'GHz': return value / 1e9;
        case 'THz': return value / 1e12;
        case 'PHz': return value / 1e15;
        default: return value;
      }
    } else if (type === 'power') {
      switch (unit) {
        case 'W_m2': return value;
        case 'kW_m2': return value / 1e3;
        case 'MW_m2': return value / 1e6;
        case 'W_cm2': return value / 1e4;
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length < 1) {
      setError('Please select at least 1 variable as given.');
      return;
    }

    try {
      let solution = {};
      let temperature, peakWavelength, peakFrequency, totalPower;

      // Start with whatever is given and calculate the rest
      if (variables.temperature.isGiven) {
        temperature = convertToBaseUnits(variables.temperature.value, variables.temperature.unit, 'temperature');
        
        // Wien's displacement law: Œª_max = b/T
        peakWavelength = constants.wienConstant / temperature;
        
        // Convert wavelength to frequency: f = c/Œª
        peakFrequency = constants.c / peakWavelength;
        
        // Stefan-Boltzmann law: j* = œÉT‚Å¥
        totalPower = constants.stefanBoltzmann * Math.pow(temperature, 4);
        
        solution.peakWavelength = peakWavelength;
        solution.peakFrequency = peakFrequency;
        solution.totalPower = totalPower;
        
      } else if (variables.peakWavelength.isGiven) {
        peakWavelength = convertToBaseUnits(variables.peakWavelength.value, variables.peakWavelength.unit, 'wavelength');
        
        // From Wien's law: T = b/Œª_max
        temperature = constants.wienConstant / peakWavelength;
        
        // Convert wavelength to frequency
        peakFrequency = constants.c / peakWavelength;
        
        // Stefan-Boltzmann law
        totalPower = constants.stefanBoltzmann * Math.pow(temperature, 4);
        
        solution.temperature = temperature;
        solution.peakFrequency = peakFrequency;
        solution.totalPower = totalPower;
        
      } else if (variables.peakFrequency.isGiven) {
        peakFrequency = convertToBaseUnits(variables.peakFrequency.value, variables.peakFrequency.unit, 'frequency');
        
        // Convert frequency to wavelength: Œª = c/f
        peakWavelength = constants.c / peakFrequency;
        
        // From Wien's law: T = b/Œª_max
        temperature = constants.wienConstant / peakWavelength;
        
        // Stefan-Boltzmann law
        totalPower = constants.stefanBoltzmann * Math.pow(temperature, 4);
        
        solution.temperature = temperature;
        solution.peakWavelength = peakWavelength;
        solution.totalPower = totalPower;
        
      } else if (variables.totalPower.isGiven) {
        totalPower = convertToBaseUnits(variables.totalPower.value, variables.totalPower.unit, 'power');
        
        // From Stefan-Boltzmann: T = (j*/œÉ)^(1/4)
        temperature = Math.pow(totalPower / constants.stefanBoltzmann, 1/4);
        
        // Wien's displacement law
        peakWavelength = constants.wienConstant / temperature;
        
        // Convert to frequency
        peakFrequency = constants.c / peakWavelength;
        
        solution.temperature = temperature;
        solution.peakWavelength = peakWavelength;
        solution.peakFrequency = peakFrequency;
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key] && !variables[key].isGiven) {
          const variable = variables[key];
          let type = 'temperature';
          if (key === 'peakWavelength') type = 'wavelength';
          if (key === 'peakFrequency') type = 'frequency';
          if (key === 'totalPower') type = 'power';
          
          const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
          
          displayResults[key] = {
            value: convertedValue,
            unit: variable.unit
          };
          
          // Format numbers appropriately
          const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
            ? convertedValue.toExponential(3)
            : convertedValue.toFixed(6).replace(/\.?0+$/, '');
          
          updatedVariables[key] = {
            ...updatedVariables[key],
            value: formattedValue
          };
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'temperature') return unitOptions.temperature;
    if (key === 'peakWavelength') return unitOptions.wavelength;
    if (key === 'peakFrequency') return unitOptions.frequency;
    if (key === 'totalPower') return unitOptions.power;
    return [];
  };

  const reset = () => {
    setVariables({
      temperature: { value: '', unit: 'K', isGiven: false },
      peakWavelength: { value: '', unit: 'nm', isGiven: false },
      peakFrequency: { value: '', unit: 'THz', isGiven: false },
      totalPower: { value: '', unit: 'W_m2', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    temperature: 'Temperature (T)',
    peakWavelength: 'Peak Wavelength (Œª_max)',
    peakFrequency: 'Peak Frequency (f_max)',
    totalPower: 'Total Power Radiated (j*)'
  };

  const variableIcons = {
    temperature: <Zap className="w-4 h-4" />,
    peakWavelength: <Ruler className="w-4 h-4" />,
    peakFrequency: <Users className="w-4 h-4" />,
    totalPower: <Rocket className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using blackbody radiation laws.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Object at 3000 K temperature. What frequency does it radiate most power at?
            </p>
          </div>
        </div>
      </div>

      {/* Constants Display */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <h4 className="text-sm font-medium text-gray-700 mb-2">Physical Constants Used:</h4>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs text-gray-600">
          <div>c = {constants.c.toExponential(2)} m/s</div>
          <div>Wien constant = {constants.wienConstant.toExponential(2)} m¬∑K</div>
          <div>œÉ = {constants.stefanBoltzmann.toExponential(3)} W/m¬≤¬∑K‚Å¥</div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {getUnitOptions(key).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 1}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 1
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Blackbody Radiation
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables using blackbody radiation laws
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses Wien's displacement law (Œª_max = b/T) to find peak wavelength, converts between wavelength and frequency (c = Œªf), 
          and applies the Stefan-Boltzmann law (j* = œÉT‚Å¥) for total radiated power. These laws describe how blackbodies radiate 
          electromagnetic energy based on their temperature.
        </p>
      </div>
    </div>
  );
};

const RelativisticEnergyCalculator = () => {
  const [variables, setVariables] = useState({
    potentialDifference: { value: '', unit: 'kV', isGiven: false },
    totalEnergy: { value: '', unit: 'MeV', isGiven: false },
    kineticEnergy: { value: '', unit: 'MeV', isGiven: false },
    velocity: { value: '', unit: 'percent_c', isGiven: false },
    momentum: { value: '', unit: 'MeV_c', isGiven: false },
    particleType: 'electron'
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  // Particle constants
  const particles = {
    electron: {
      mass: 9.11e-31, // kg
      charge: 1.60e-19, // C (magnitude)
      name: 'Electron',
      restEnergyMeV: 0.511 // MeV
    },
    proton: {
      mass: 1.67e-27, // kg
      charge: 1.60e-19, // C
      name: 'Proton',
      restEnergyMeV: 938.3 // MeV
    }
  };

  const unitOptions = {
    voltage: [
      { value: 'V', label: 'Volts' },
      { value: 'kV', label: 'Kilovolts' },
      { value: 'MV', label: 'Megavolts' }
    ],
    energy: [
      { value: 'J', label: 'Joules' },
      { value: 'eV', label: 'Electron volts' },
      { value: 'keV', label: 'Kiloelectron volts' },
      { value: 'MeV', label: 'Megaelectron volts' },
      { value: 'GeV', label: 'Gigaelectron volts' }
    ],
    velocity: [
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c (0-1)' },
      { value: 'km_s', label: 'km/s' },
      { value: 'm_s', label: 'm/s' }
    ],
    momentum: [
      { value: 'kg_m_s', label: 'kg‚ãÖm/s' },
      { value: 'MeV_c', label: 'MeV/c' },
      { value: 'GeV_c', label: 'GeV/c' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'voltage') {
      switch (unit) {
        case 'V': return val;
        case 'kV': return val * 1000;
        case 'MV': return val * 1000000;
        default: return val;
      }
    } else if (type === 'energy') {
      const eV_to_J = 1.60e-19;
      switch (unit) {
        case 'J': return val;
        case 'eV': return val * eV_to_J;
        case 'keV': return val * eV_to_J * 1000;
        case 'MeV': return val * eV_to_J * 1000000;
        case 'GeV': return val * eV_to_J * 1000000000;
        default: return val;
      }
    } else if (type === 'velocity') {
      const c = 299792458; // m/s
      switch (unit) {
        case 'fraction_c': return val;
        case 'percent_c': return val / 100;
        case 'km_s': return (val * 1000) / c;
        case 'm_s': return val / c;
        default: return val;
      }
    } else if (type === 'momentum') {
      const c = 299792458; // m/s
      const eV_to_J = 1.60e-19;
      switch (unit) {
        case 'kg_m_s': return val;
        case 'MeV_c': return (val * eV_to_J * 1000000) / c;
        case 'GeV_c': return (val * eV_to_J * 1000000000) / c;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'voltage') {
      switch (unit) {
        case 'V': return value;
        case 'kV': return value / 1000;
        case 'MV': return value / 1000000;
        default: return value;
      }
    } else if (type === 'energy') {
      const eV_to_J = 1.60e-19;
      switch (unit) {
        case 'J': return value;
        case 'eV': return value / eV_to_J;
        case 'keV': return value / (eV_to_J * 1000);
        case 'MeV': return value / (eV_to_J * 1000000);
        case 'GeV': return value / (eV_to_J * 1000000000);
        default: return value;
      }
    } else if (type === 'velocity') {
      const c = 299792458; // m/s
      switch (unit) {
        case 'fraction_c': return value;
        case 'percent_c': return value * 100;
        case 'km_s': return (value * c) / 1000;
        case 'm_s': return value * c;
        default: return value;
      }
    } else if (type === 'momentum') {
      const c = 299792458; // m/s
      const eV_to_J = 1.60e-19;
      switch (unit) {
        case 'kg_m_s': return value;
        case 'MeV_c': return (value * c) / (eV_to_J * 1000000);
        case 'GeV_c': return (value * c) / (eV_to_J * 1000000000);
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => 
      variables[key].isGiven && key !== 'particleType'
    );
    
    if (givenVars.length < 1) {
      setError('Please select at least 1 variable as given.');
      return;
    }

    try {
      const particle = particles[variables.particleType];
      const c = 299792458; // m/s
      const m = particle.mass;
      const q = particle.charge;
      const restEnergy = m * c * c; // in Joules
      const restEnergyMeV = particle.restEnergyMeV;

      let solution = {};
      let gamma, v, totalEnergy, kineticEnergy, momentum, potentialDifference;

      // If potential difference is given, start from there (most common case)
      if (variables.potentialDifference.isGiven) {
        const givenV = convertToBaseUnits(variables.potentialDifference.value, variables.potentialDifference.unit, 'voltage');
        
        // KE = qV (energy gained from potential difference)
        kineticEnergy = q * givenV;
        
        // Total energy = rest energy + kinetic energy
        totalEnergy = restEnergy + kineticEnergy;
        
        // Calculate gamma from total energy
        gamma = totalEnergy / restEnergy;
        
        // Calculate velocity
        v = Math.sqrt(1 - 1/(gamma * gamma)); // fraction of c
        
        // Calculate momentum
        momentum = gamma * m * v * c;
        
        solution.totalEnergy = totalEnergy;
        solution.kineticEnergy = kineticEnergy;
        solution.velocity = v;
        solution.momentum = momentum;
        
      } else if (variables.totalEnergy.isGiven) {
        totalEnergy = convertToBaseUnits(variables.totalEnergy.value, variables.totalEnergy.unit, 'energy');
        gamma = totalEnergy / restEnergy;
        if (gamma < 1) {
          throw new Error('Total energy cannot be less than rest energy');
        }
        kineticEnergy = totalEnergy - restEnergy;
        v = Math.sqrt(1 - 1/(gamma * gamma));
        momentum = gamma * m * v * c;
        potentialDifference = kineticEnergy / q;
        
        solution.potentialDifference = potentialDifference;
        solution.kineticEnergy = kineticEnergy;
        solution.velocity = v;
        solution.momentum = momentum;
        
      } else if (variables.kineticEnergy.isGiven) {
        kineticEnergy = convertToBaseUnits(variables.kineticEnergy.value, variables.kineticEnergy.unit, 'energy');
        gamma = 1 + kineticEnergy / restEnergy;
        totalEnergy = gamma * restEnergy;
        v = Math.sqrt(1 - 1/(gamma * gamma));
        momentum = gamma * m * v * c;
        potentialDifference = kineticEnergy / q;
        
        solution.potentialDifference = potentialDifference;
        solution.totalEnergy = totalEnergy;
        solution.velocity = v;
        solution.momentum = momentum;
        
      } else if (variables.velocity.isGiven) {
        v = convertToBaseUnits(variables.velocity.value, variables.velocity.unit, 'velocity');
        if (v >= 1) {
          throw new Error('Velocity cannot equal or exceed the speed of light');
        }
        gamma = 1 / Math.sqrt(1 - v * v);
        totalEnergy = gamma * restEnergy;
        kineticEnergy = totalEnergy - restEnergy;
        momentum = gamma * m * v * c;
        potentialDifference = kineticEnergy / q;
        
        solution.potentialDifference = potentialDifference;
        solution.totalEnergy = totalEnergy;
        solution.kineticEnergy = kineticEnergy;
        solution.momentum = momentum;
        
      } else if (variables.momentum.isGiven) {
        momentum = convertToBaseUnits(variables.momentum.value, variables.momentum.unit, 'momentum');
        // From E¬≤ = (pc)¬≤ + (mc¬≤)¬≤
        totalEnergy = Math.sqrt((momentum * c) * (momentum * c) + restEnergy * restEnergy);
        gamma = totalEnergy / restEnergy;
        kineticEnergy = totalEnergy - restEnergy;
        v = Math.sqrt(1 - 1/(gamma * gamma));
        potentialDifference = kineticEnergy / q;
        
        solution.potentialDifference = potentialDifference;
        solution.totalEnergy = totalEnergy;
        solution.kineticEnergy = kineticEnergy;
        solution.velocity = v;
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        if (variables[key] && !variables[key].isGiven) {
          const variable = variables[key];
          let type = 'energy';
          if (key === 'potentialDifference') type = 'voltage';
          if (key === 'velocity') type = 'velocity';
          if (key === 'momentum') type = 'momentum';
          
          const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
          
          displayResults[key] = {
            value: convertedValue,
            unit: variable.unit
          };
          
          // Update the input box with the calculated value
          const formattedValue = Math.abs(convertedValue) > 1e6 || (Math.abs(convertedValue) < 1e-3 && Math.abs(convertedValue) > 0) 
            ? convertedValue.toExponential(3)
            : convertedValue.toFixed(6).replace(/\.?0+$/, '');
          
          updatedVariables[key] = {
            ...updatedVariables[key],
            value: formattedValue
          };
        }
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    if (key === 'particleType') return;
    
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], isGiven: !prev[key].isGiven }
    }));
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const updateParticleType = (particleType) => {
    setVariables(prev => ({
      ...prev,
      particleType
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'potentialDifference') return unitOptions.voltage;
    if (key === 'velocity') return unitOptions.velocity;
    if (key === 'momentum') return unitOptions.momentum;
    return unitOptions.energy;
  };

  const reset = () => {
    setVariables({
      potentialDifference: { value: '', unit: 'kV', isGiven: false },
      totalEnergy: { value: '', unit: 'MeV', isGiven: false },
      kineticEnergy: { value: '', unit: 'MeV', isGiven: false },
      velocity: { value: '', unit: 'percent_c', isGiven: false },
      momentum: { value: '', unit: 'MeV_c', isGiven: false },
      particleType: 'electron'
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    potentialDifference: 'Potential Difference (V)',
    totalEnergy: 'Total Energy (E)',
    kineticEnergy: 'Kinetic Energy (KE)',
    velocity: 'Velocity (v)',
    momentum: 'Momentum (p)'
  };

  const variableIcons = {
    potentialDifference: <Zap className="w-4 h-4" />,
    totalEnergy: <Users className="w-4 h-4" />,
    kineticEnergy: <Rocket className="w-4 h-4" />,
    velocity: <Rocket className="w-4 h-4" />,
    momentum: <Users className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => 
    variables[key].isGiven && key !== 'particleType'
  ).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select any variables as "given" (known) and the calculator will solve for all others using relativistic energy equations.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Electron accelerated through 50.0 kV. What's its total energy?
            </p>
          </div>
        </div>
      </div>

      {/* Particle Type Selection */}
      <div className="bg-gray-50 rounded-lg p-4 border mb-6">
        <label className="text-sm font-medium text-gray-700 mb-3 block">Particle Type:</label>
        <div className="flex gap-4">
          {Object.keys(particles).map(type => (
            <button
              key={type}
              onClick={() => updateParticleType(type)}
              className={`px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                variables.particleType === type
                  ? 'bg-blue-100 text-blue-800 border border-blue-300'
                  : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
              }`}
            >
              {particles[type].name}
            </button>
          ))}
        </div>
        <p className="text-xs text-gray-500 mt-2">
          {particles[variables.particleType].name}: Rest Energy = {particles[variables.particleType].restEnergyMeV} MeV, 
          q = {particles[variables.particleType].charge.toExponential(2)} C
        </p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).filter(key => key !== 'particleType').map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {getUnitOptions(key).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount < 1}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount >= 1
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Relativistic Energy
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount} variable{givenCount !== 1 ? 's' : ''} as given
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variables for {particles[variables.particleType].name.toLowerCase()}
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses relativistic energy equations: E = Œ≥mc¬≤, KE = E - mc¬≤, p = Œ≥mv, and KE = qV for charged particles.
          The Lorentz factor Œ≥ = 1/‚àö(1-v¬≤/c¬≤) accounts for relativistic effects at high speeds.
          Rest energy E‚ÇÄ = mc¬≤ is the energy equivalent of the particle's rest mass.
        </p>
      </div>
    </div>
  );
};

const TwinParadoxCalculator = () => {
  const [variables, setVariables] = useState({
    initialAge: { value: '', unit: 'years', isGiven: false },
    speed: { value: '', unit: 'percent_c', isGiven: false },
    timeElapsed: { value: '', unit: 'years', isGiven: false },
    finalAgeEarth: { value: '', unit: 'years', isGiven: false },
    finalAgeSpace: { value: '', unit: 'years', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  const unitOptions = {
    age: [
      { value: 'years', label: 'Years' },
      { value: 'months', label: 'Months' },
      { value: 'days', label: 'Days' }
    ],
    speed: [
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c (0-1)' },
      { value: 'km_s', label: 'km/s' },
      { value: 'mi_hr', label: 'mph' },
      { value: 'm_s', label: 'm/s' }
    ],
    time: [
      { value: 'years', label: 'Years' },
      { value: 'months', label: 'Months' },
      { value: 'days', label: 'Days' },
      { value: 'hours', label: 'Hours' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'age' || type === 'time') {
      switch (unit) {
        case 'years': return val;
        case 'months': return val / 12;
        case 'days': return val / 365.25;
        case 'hours': return val / (365.25 * 24);
        default: return val;
      }
    } else if (type === 'speed') {
      const c = 299792458; // m/s
      const c_mph = 670616629; // mph (approximately)
      switch (unit) {
        case 'fraction_c': return val;
        case 'percent_c': return val / 100;
        case 'km_s': return (val * 1000) / c;
        case 'mi_hr': return val / c_mph;
        case 'm_s': return val / c;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'age' || type === 'time') {
      switch (unit) {
        case 'years': return value;
        case 'months': return value * 12;
        case 'days': return value * 365.25;
        case 'hours': return value * 365.25 * 24;
        default: return value;
      }
    } else if (type === 'speed') {
      const c = 299792458; // m/s
      const c_mph = 670616629; // mph (approximately)
      switch (unit) {
        case 'fraction_c': return value;
        case 'percent_c': return value * 100;
        case 'km_s': return (value * c) / 1000;
        case 'mi_hr': return value * c_mph;
        case 'm_s': return value * c;
        default: return value;
      }
    }
    return value;
  };

  const lorentzFactor = (v) => {
    if (v >= 1) return Infinity;
    return 1 / Math.sqrt(1 - v * v);
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length !== 3) {
      setError('Please select exactly 3 variables as given and 2 as unknown.');
      return;
    }

    try {
      // Convert all given values to base units
      const values = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        let type = 'age';
        if (key === 'speed') type = 'speed';
        if (key === 'timeElapsed') type = 'time';
        
        values[key] = convertToBaseUnits(variable.value, variable.unit, type);
      });

      let solution = {};

      // Handle different combinations
      const combo = givenVars.sort().join(',');
      
      switch (combo) {
        case 'initialAge,speed,timeElapsed':
          // Given: initial age, speed, time elapsed
          const gamma1 = lorentzFactor(values.speed);
          const spaceTime1 = values.timeElapsed / gamma1;
          solution.finalAgeEarth = values.initialAge + values.timeElapsed;
          solution.finalAgeSpace = values.initialAge + spaceTime1;
          break;

        case 'finalAgeEarth,initialAge,speed':
          // Given: initial age, speed, final age of Earth twin
          const timeElapsed2 = values.finalAgeEarth - values.initialAge;
          const gamma2 = lorentzFactor(values.speed);
          const spaceTime2 = timeElapsed2 / gamma2;
          solution.timeElapsed = timeElapsed2;
          solution.finalAgeSpace = values.initialAge + spaceTime2;
          break;

        case 'finalAgeSpace,initialAge,speed':
          // Given: initial age, speed, final age of space twin
          const spaceTime3 = values.finalAgeSpace - values.initialAge;
          const gamma3 = lorentzFactor(values.speed);
          const timeElapsed3 = spaceTime3 * gamma3;
          solution.timeElapsed = timeElapsed3;
          solution.finalAgeEarth = values.initialAge + timeElapsed3;
          break;

        case 'finalAgeEarth,initialAge,timeElapsed':
          // Given: initial age, time elapsed, final age of Earth twin
          const checkTime4 = values.finalAgeEarth - values.initialAge;
          if (Math.abs(checkTime4 - values.timeElapsed) > 0.001) {
            throw new Error('Inconsistent values: final age of Earth twin should equal initial age + time elapsed');
          }
          throw new Error('This combination requires additional constraints. Please provide the space twin\'s final age instead.');
          
        case 'finalAgeSpace,initialAge,timeElapsed':
          // Given: initial age, time elapsed, final age of space twin
          const spaceTime5 = values.finalAgeSpace - values.initialAge;
          const gamma5 = values.timeElapsed / spaceTime5;
          const vSquared5 = 1 - (1 / (gamma5 * gamma5));
          if (vSquared5 < 0 || vSquared5 >= 1) {
            throw new Error('No valid solution: check your input values');
          }
          const speed5 = Math.sqrt(vSquared5);
          solution.speed = speed5;
          solution.finalAgeEarth = values.initialAge + values.timeElapsed;
          break;

        case 'finalAgeEarth,finalAgeSpace,initialAge':
          // Given: initial age, both final ages
          const earthTime6 = values.finalAgeEarth - values.initialAge;
          const spaceTime6 = values.finalAgeSpace - values.initialAge;
          const gamma6 = earthTime6 / spaceTime6;
          const vSquared6 = 1 - (1 / (gamma6 * gamma6));
          if (vSquared6 < 0 || vSquared6 >= 1) {
            throw new Error('No valid solution: space twin cannot age more than Earth twin');
          }
          const speed6 = Math.sqrt(vSquared6);
          solution.speed = speed6;
          solution.timeElapsed = earthTime6;
          break;

        case 'finalAgeEarth,speed,timeElapsed':
          // Given: speed, time elapsed, final age of Earth twin
          const checkTime7 = values.finalAgeEarth - values.timeElapsed;
          const gamma7 = lorentzFactor(values.speed);
          const spaceTime7 = values.timeElapsed / gamma7;
          solution.initialAge = checkTime7;
          solution.finalAgeSpace = checkTime7 + spaceTime7;
          break;

        case 'finalAgeSpace,speed,timeElapsed':
          // Given: speed, time elapsed, final age of space twin
          const gamma8 = lorentzFactor(values.speed);
          const spaceTime8 = values.timeElapsed / gamma8;
          const initialAge8 = values.finalAgeSpace - spaceTime8;
          solution.initialAge = initialAge8;
          solution.finalAgeEarth = initialAge8 + values.timeElapsed;
          break;

        case 'finalAgeEarth,finalAgeSpace,speed':
          // Given: speed, both final ages
          const gamma9 = lorentzFactor(values.speed);
          const ageDiff9 = values.finalAgeEarth - values.finalAgeSpace;
          const timeElapsed9 = ageDiff9 / (1 - 1/gamma9);
          const initialAge9 = values.finalAgeEarth - timeElapsed9;
          solution.initialAge = initialAge9;
          solution.timeElapsed = timeElapsed9;
          break;

        case 'finalAgeEarth,finalAgeSpace,timeElapsed':
          // Given: time elapsed, both final ages
          const earthTime10 = values.timeElapsed;
          const initialAge10 = values.finalAgeEarth - earthTime10;
          const spaceTime10 = values.finalAgeSpace - initialAge10;
          const gamma10 = earthTime10 / spaceTime10;
          const vSquared10 = 1 - (1 / (gamma10 * gamma10));
          if (vSquared10 < 0 || vSquared10 >= 1) {
            throw new Error('No valid solution: check your input values');
          }
          solution.speed = Math.sqrt(vSquared10);
          solution.initialAge = initialAge10;
          break;

        default:
          throw new Error('This combination is not yet supported');
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        const variable = variables[key];
        let type = 'age';
        if (key === 'speed') type = 'speed';
        if (key === 'timeElapsed') type = 'time';
        
        const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
        
        displayResults[key] = {
          value: convertedValue,
          unit: variable.unit
        };
        
        // Update the input box with the calculated value
        updatedVariables[key] = {
          ...updatedVariables[key],
          value: convertedValue.toFixed(6).replace(/\.?0+$/, '') // Remove trailing zeros
        };
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    const currentGiven = Object.keys(variables).filter(k => variables[k].isGiven);
    
    if (variables[key].isGiven) {
      // Removing a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: false }
      }));
    } else if (currentGiven.length < 3) {
      // Adding a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: true }
      }));
    }
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'speed') return unitOptions.speed;
    if (key === 'timeElapsed') return unitOptions.time;
    return unitOptions.age;
  };

  const reset = () => {
    setVariables({
      initialAge: { value: '', unit: 'years', isGiven: false },
      speed: { value: '', unit: 'percent_c', isGiven: false },
      timeElapsed: { value: '', unit: 'years', isGiven: false },
      finalAgeEarth: { value: '', unit: 'years', isGiven: false },
      finalAgeSpace: { value: '', unit: 'years', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    initialAge: 'Initial Age (Both Twins)',
    speed: 'Speed of Space Twin',
    timeElapsed: 'Time Elapsed on Earth',
    finalAgeEarth: 'Final Age (Earth Twin)',
    finalAgeSpace: 'Final Age (Space Twin)'
  };

  const variableIcons = {
    initialAge: <Users className="w-4 h-4" />,
    speed: <Rocket className="w-4 h-4" />,
    timeElapsed: <Clock className="w-4 h-4" />,
    finalAgeEarth: <Users className="w-4 h-4" />,
    finalAgeSpace: <Rocket className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select exactly 3 variables as "given" (known) and the calculator will solve for the remaining 2 unknowns using Einstein's special relativity equations.
            </p>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={!variables[key].isGiven && givenCount >= 3}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : givenCount >= 3
                    ? 'bg-gray-100 text-gray-400 border border-gray-200 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {getUnitOptions(key).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount !== 3}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount === 3
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Twin Paradox
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount}/3 variables
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variable{Object.keys(results).length > 1 ? 's' : ''}: {' '}
            {Object.keys(results).map(key => variableLabels[key]).join(', ')}
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses Einstein's time dilation formula: Œît' = Œît/Œ≥ where Œ≥ = 1/‚àö(1-v¬≤/c¬≤). 
          The traveling twin experiences less time due to their high-speed motion relative to Earth.
          Speed values at or above the speed of light are not physically meaningful.
        </p>
      </div>
    </div>
  );
};

const LengthContractionCalculator = () => {
  const [variables, setVariables] = useState({
    properLength: { value: '', unit: 'm', isGiven: false },
    contractedLength: { value: '', unit: 'm', isGiven: false },
    velocity: { value: '', unit: 'percent_c', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  const unitOptions = {
    length: [
      { value: 'm', label: 'Meters' },
      { value: 'km', label: 'Kilometers' },
      { value: 'cm', label: 'Centimeters' },
      { value: 'mm', label: 'Millimeters' },
      { value: 'ft', label: 'Feet' },
      { value: 'in', label: 'Inches' }
    ],
    velocity: [
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c (0-1)' },
      { value: 'km_s', label: 'km/s' },
      { value: 'mi_hr', label: 'mph' },
      { value: 'm_s', label: 'm/s' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'length') {
      switch (unit) {
        case 'm': return val;
        case 'km': return val * 1000;
        case 'cm': return val / 100;
        case 'mm': return val / 1000;
        case 'ft': return val * 0.3048;
        case 'in': return val * 0.0254;
        default: return val;
      }
    } else if (type === 'velocity') {
      const c = 299792458; // m/s
      const c_mph = 670616629; // mph (approximately)
      switch (unit) {
        case 'fraction_c': return val;
        case 'percent_c': return val / 100;
        case 'km_s': return (val * 1000) / c;
        case 'mi_hr': return val / c_mph;
        case 'm_s': return val / c;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'length') {
      switch (unit) {
        case 'm': return value;
        case 'km': return value / 1000;
        case 'cm': return value * 100;
        case 'mm': return value * 1000;
        case 'ft': return value / 0.3048;
        case 'in': return value / 0.0254;
        default: return value;
      }
    } else if (type === 'velocity') {
      const c = 299792458; // m/s
      const c_mph = 670616629; // mph (approximately)
      switch (unit) {
        case 'fraction_c': return value;
        case 'percent_c': return value * 100;
        case 'km_s': return (value * c) / 1000;
        case 'mi_hr': return value * c_mph;
        case 'm_s': return value * c;
        default: return value;
      }
    }
    return value;
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length !== 2) {
      setError('Please select exactly 2 variables as given and 1 as unknown.');
      return;
    }

    try {
      // Convert all given values to base units
      const values = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        let type = 'length';
        if (key === 'velocity') type = 'velocity';
        
        values[key] = convertToBaseUnits(variable.value, variable.unit, type);
      });

      let solution = {};

      // Handle different combinations
      const combo = givenVars.sort().join(',');
      
      switch (combo) {
        case 'properLength,velocity':
          // Given: proper length and velocity, find contracted length
          // L = L‚ÇÄ * ‚àö(1 - v¬≤/c¬≤)
          if (values.velocity >= 1) {
            throw new Error('Velocity cannot be at or above the speed of light');
          }
          const gamma1 = Math.sqrt(1 - values.velocity * values.velocity);
          solution.contractedLength = values.properLength * gamma1;
          break;

        case 'contractedLength,velocity':
          // Given: contracted length and velocity, find proper length
          // L‚ÇÄ = L / ‚àö(1 - v¬≤/c¬≤)
          if (values.velocity >= 1) {
            throw new Error('Velocity cannot be at or above the speed of light');
          }
          const gamma2 = Math.sqrt(1 - values.velocity * values.velocity);
          solution.properLength = values.contractedLength / gamma2;
          break;

        case 'contractedLength,properLength':
          // Given: both lengths, find velocity
          // v = c * ‚àö(1 - (L/L‚ÇÄ)¬≤)
          const ratio = values.contractedLength / values.properLength;
          if (ratio > 1) {
            throw new Error('Contracted length cannot be greater than proper length');
          }
          if (ratio <= 0) {
            throw new Error('Length ratio must be positive');
          }
          const vSquared = 1 - (ratio * ratio);
          if (vSquared < 0) {
            throw new Error('No valid solution: check your input values');
          }
          solution.velocity = Math.sqrt(vSquared);
          break;

        default:
          throw new Error('This combination is not supported');
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        const variable = variables[key];
        let type = 'length';
        if (key === 'velocity') type = 'velocity';
        
        const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
        
        displayResults[key] = {
          value: convertedValue,
          unit: variable.unit
        };
        
        // Update the input box with the calculated value
        updatedVariables[key] = {
          ...updatedVariables[key],
          value: convertedValue.toFixed(6).replace(/\.?0+$/, '') // Remove trailing zeros
        };
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    const currentGiven = Object.keys(variables).filter(k => variables[k].isGiven);
    
    if (variables[key].isGiven) {
      // Removing a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: false }
      }));
    } else if (currentGiven.length < 2) {
      // Adding a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: true }
      }));
    }
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'velocity') return unitOptions.velocity;
    return unitOptions.length;
  };

  const reset = () => {
    setVariables({
      properLength: { value: '', unit: 'm', isGiven: false },
      contractedLength: { value: '', unit: 'm', isGiven: false },
      velocity: { value: '', unit: 'percent_c', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    properLength: 'Proper Length (Rest Frame)',
    contractedLength: 'Contracted Length (Moving Frame)',
    velocity: 'Relative Velocity'
  };

  const variableIcons = {
    properLength: <Ruler className="w-4 h-4" />,
    contractedLength: <Zap className="w-4 h-4" />,
    velocity: <Rocket className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select exactly 2 variables as "given" (known) and the calculator will solve for the remaining unknown using Einstein's length contraction formula.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> A 517 m particle accelerator moving at 0.625c appears shorter to the particle due to length contraction.
            </p>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={!variables[key].isGiven && givenCount >= 2}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : givenCount >= 2
                    ? 'bg-gray-100 text-gray-400 border border-gray-200 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {getUnitOptions(key).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount !== 2}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount === 2
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Length Contraction
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount}/2 variables
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated {Object.keys(results).length} unknown variable: {' '}
            {Object.keys(results).map(key => variableLabels[key]).join(', ')}
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses Einstein's length contraction formula: L = L‚ÇÄ √ó ‚àö(1 - v¬≤/c¬≤). 
          Objects appear shorter in the direction of motion when observed from a different reference frame.
          The proper length is measured in the object's rest frame, while the contracted length is measured in a frame where the object is moving.
        </p>
      </div>
    </div>
  );
};

const LorentzTransformCalculator = () => {
  const [variables, setVariables] = useState({
    x: { value: '', unit: 'm', isGiven: false },
    t: { value: '', unit: 'Œºs', isGiven: false },
    xPrime: { value: '', unit: 'm', isGiven: false },
    tPrime: { value: '', unit: 'Œºs', isGiven: false },
    velocity: { value: '', unit: 'percent_c', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  const unitOptions = {
    position: [
      { value: 'm', label: 'Meters' },
      { value: 'km', label: 'Kilometers' },
      { value: 'cm', label: 'Centimeters' },
      { value: 'mm', label: 'Millimeters' },
      { value: 'ft', label: 'Feet' },
      { value: 'in', label: 'Inches' }
    ],
    time: [
      { value: 's', label: 'Seconds' },
      { value: 'ms', label: 'Milliseconds' },
      { value: 'Œºs', label: 'Microseconds' },
      { value: 'ns', label: 'Nanoseconds' },
      { value: 'min', label: 'Minutes' },
      { value: 'hr', label: 'Hours' }
    ],
    velocity: [
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c (0-1)' },
      { value: 'km_s', label: 'km/s' },
      { value: 'mi_hr', label: 'mph' },
      { value: 'm_s', label: 'm/s' }
    ]
  };

  const convertToBaseUnits = (value, unit, type) => {
    if (!value) return 0;
    const val = parseFloat(value);
    
    if (type === 'position') {
      switch (unit) {
        case 'm': return val;
        case 'km': return val * 1000;
        case 'cm': return val / 100;
        case 'mm': return val / 1000;
        case 'ft': return val * 0.3048;
        case 'in': return val * 0.0254;
        default: return val;
      }
    } else if (type === 'time') {
      switch (unit) {
        case 's': return val;
        case 'ms': return val / 1000;
        case 'Œºs': return val / 1000000;
        case 'ns': return val / 1000000000;
        case 'min': return val * 60;
        case 'hr': return val * 3600;
        default: return val;
      }
    } else if (type === 'velocity') {
      const c = 299792458; // m/s
      const c_mph = 670616629; // mph (approximately)
      switch (unit) {
        case 'fraction_c': return val;
        case 'percent_c': return val / 100;
        case 'km_s': return (val * 1000) / c;
        case 'mi_hr': return val / c_mph;
        case 'm_s': return val / c;
        default: return val;
      }
    }
    return val;
  };

  const convertFromBaseUnits = (value, unit, type) => {
    if (type === 'position') {
      switch (unit) {
        case 'm': return value;
        case 'km': return value / 1000;
        case 'cm': return value * 100;
        case 'mm': return value * 1000;
        case 'ft': return value / 0.3048;
        case 'in': return value / 0.0254;
        default: return value;
      }
    } else if (type === 'time') {
      switch (unit) {
        case 's': return value;
        case 'ms': return value * 1000;
        case 'Œºs': return value * 1000000;
        case 'ns': return value * 1000000000;
        case 'min': return value / 60;
        case 'hr': return value / 3600;
        default: return value;
      }
    } else if (type === 'velocity') {
      const c = 299792458; // m/s
      const c_mph = 670616629; // mph (approximately)
      switch (unit) {
        case 'fraction_c': return value;
        case 'percent_c': return value * 100;
        case 'km_s': return (value * c) / 1000;
        case 'mi_hr': return value * c_mph;
        case 'm_s': return value * c;
        default: return value;
      }
    }
    return value;
  };

  const lorentzFactor = (v) => {
    if (v >= 1) return Infinity;
    return 1 / Math.sqrt(1 - v * v);
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length !== 4) {
      setError('Please select exactly 4 variables as given and 1 as unknown.');
      return;
    }

    try {
      // Convert all given values to base units
      const values = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        let type = 'position';
        if (key === 't' || key === 'tPrime') type = 'time';
        if (key === 'velocity') type = 'velocity';
        
        values[key] = convertToBaseUnits(variable.value, variable.unit, type);
      });

      let solution = {};
      const c = 299792458; // speed of light in m/s
      const unknownVar = Object.keys(variables).find(key => !variables[key].isGiven);

      // Determine what we're solving for and use appropriate Lorentz transformation
      switch (unknownVar) {
        case 'x':
          // Solve for x using: x = Œ≥(x' + vt')
          const gamma_x = lorentzFactor(values.velocity);
          solution.x = gamma_x * (values.xPrime + values.velocity * c * values.tPrime);
          break;

        case 't':
          // Solve for t using: t = Œ≥(t' + vx'/c¬≤)
          const gamma_t = lorentzFactor(values.velocity);
          solution.t = gamma_t * (values.tPrime + (values.velocity * values.xPrime) / c);
          break;

        case 'xPrime':
          // Solve for x' using: x' = Œ≥(x - vt)
          const gamma_xp = lorentzFactor(values.velocity);
          solution.xPrime = gamma_xp * (values.x - values.velocity * c * values.t);
          break;

        case 'tPrime':
          // Solve for t' using: t' = Œ≥(t - vx/c¬≤)
          const gamma_tp = lorentzFactor(values.velocity);
          solution.tPrime = gamma_tp * (values.t - (values.velocity * values.x) / c);
          break;

        case 'velocity':
          // This is more complex - need to solve the system of equations
          if (!values.x || !values.t || !values.xPrime || !values.tPrime) {
            throw new Error('All position and time coordinates must be given to solve for velocity');
          }
          
          const A = values.t * values.t * c * c - values.x * values.x;
          const B = 2 * (values.x * values.tPrime * c - values.t * values.xPrime * c);
          const C = values.xPrime * values.xPrime - values.tPrime * values.tPrime * c * c;
          
          const discriminant = B * B - 4 * A * C;
          if (discriminant < 0) {
            throw new Error('No real solution exists for the given coordinates');
          }
          
          const v1 = (-B + Math.sqrt(discriminant)) / (2 * A);
          const v2 = (-B - Math.sqrt(discriminant)) / (2 * A);
          
          // Choose the solution with |v| < c
          let v_solution;
          if (Math.abs(v1) < c && Math.abs(v2) < c) {
            v_solution = Math.abs(v1) < Math.abs(v2) ? v1 : v2;
          } else if (Math.abs(v1) < c) {
            v_solution = v1;
          } else if (Math.abs(v2) < c) {
            v_solution = v2;
          } else {
            throw new Error('No physically valid solution (|v| < c) found');
          }
          
          solution.velocity = v_solution / c; // Convert to fraction of c
          break;

        default:
          throw new Error('Unknown variable to solve for');
      }

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        const variable = variables[key];
        let type = 'position';
        if (key === 't' || key === 'tPrime') type = 'time';
        if (key === 'velocity') type = 'velocity';
        
        const convertedValue = convertFromBaseUnits(solution[key], variable.unit, type);
        
        displayResults[key] = {
          value: convertedValue,
          unit: variable.unit
        };
        
        // Update the input box with the calculated value
        updatedVariables[key] = {
          ...updatedVariables[key],
          value: convertedValue.toFixed(6).replace(/\.?0+$/, '') // Remove trailing zeros
        };
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    const currentGiven = Object.keys(variables).filter(k => variables[k].isGiven);
    
    if (variables[key].isGiven) {
      // Removing a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: false }
      }));
    } else if (currentGiven.length < 4) {
      // Adding a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: true }
      }));
    }
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const getUnitOptions = (key) => {
    if (key === 'velocity') return unitOptions.velocity;
    if (key === 't' || key === 'tPrime') return unitOptions.time;
    return unitOptions.position;
  };

  const reset = () => {
    setVariables({
      x: { value: '', unit: 'm', isGiven: false },
      t: { value: '', unit: 'Œºs', isGiven: false },
      xPrime: { value: '', unit: 'm', isGiven: false },
      tPrime: { value: '', unit: 'Œºs', isGiven: false },
      velocity: { value: '', unit: 'percent_c', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    x: 'Position x (Frame S)',
    t: 'Time t (Frame S)',
    xPrime: "Position x' (Frame S')",
    tPrime: "Time t' (Frame S')",
    velocity: "Relative Velocity v (S' relative to S)"
  };

  const variableIcons = {
    x: <Ruler className="w-4 h-4" />,
    t: <Clock className="w-4 h-4" />,
    xPrime: <Zap className="w-4 h-4" />,
    tPrime: <Zap className="w-4 h-4" />,
    velocity: <Rocket className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select exactly 4 variables as "given" (known) and the calculator will solve for the remaining unknown using Lorentz transformation equations.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Frame S' moves at +0.56c relative to S. An event at x=800m, t=3.0Œºs in S has what t' in S'?
            </p>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={!variables[key].isGiven && givenCount >= 4}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : givenCount >= 4
                    ? 'bg-gray-100 text-gray-400 border border-gray-200 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {getUnitOptions(key).map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount !== 4}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount === 4
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Lorentz Transform
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount}/4 variables
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated unknown variable: {' '}
            {Object.keys(results).map(key => variableLabels[key]).join(', ')}
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses the Lorentz transformation equations: x' = Œ≥(x - vt) and t' = Œ≥(t - vx/c¬≤), where Œ≥ = 1/‚àö(1 - v¬≤/c¬≤). 
          These equations relate space and time coordinates between reference frames in relative motion.
          Frame S' moves with velocity v relative to frame S, and both frames use the same origin when t = t' = 0.
        </p>
      </div>
    </div>
  );
};

const VelocityAdditionCalculator = () => {
  const [variables, setVariables] = useState({
    v1: { value: '', unit: 'percent_c', isGiven: false },
    v2: { value: '', unit: 'percent_c', isGiven: false },
    vTotal: { value: '', unit: 'percent_c', isGiven: false }
  });

  const [results, setResults] = useState(null);
  const [error, setError] = useState('');

  const unitOptions = {
    velocity: [
      { value: 'percent_c', label: 'Percentage of c' },
      { value: 'fraction_c', label: 'Fraction of c (0-1)' },
      { value: 'km_s', label: 'km/s' },
      { value: 'mi_hr', label: 'mph' },
      { value: 'm_s', label: 'm/s' }
    ]
  };

  const convertToBaseUnits = (value, unit) => {
    if (!value) return 0;
    const val = parseFloat(value);
    const c = 299792458; // m/s
    const c_mph = 670616629; // mph (approximately)
    
    switch (unit) {
      case 'fraction_c': return val;
      case 'percent_c': return val / 100;
      case 'km_s': return (val * 1000) / c;
      case 'mi_hr': return val / c_mph;
      case 'm_s': return val / c;
      default: return val;
    }
  };

  const convertFromBaseUnits = (value, unit) => {
    const c = 299792458; // m/s
    const c_mph = 670616629; // mph (approximately)
    
    switch (unit) {
      case 'fraction_c': return value;
      case 'percent_c': return value * 100;
      case 'km_s': return (value * c) / 1000;
      case 'mi_hr': return value * c_mph;
      case 'm_s': return value * c;
      default: return value;
    }
  };

  const solvePhysics = () => {
    const givenVars = Object.keys(variables).filter(key => variables[key].isGiven);
    
    if (givenVars.length !== 2) {
      setError('Please select exactly 2 variables as given and 1 as unknown.');
      return;
    }

    try {
      // Convert all given values to base units (fractions of c)
      const values = {};
      givenVars.forEach(key => {
        const variable = variables[key];
        values[key] = convertToBaseUnits(variable.value, variable.unit);
      });

      let solution = {};
      const unknownVar = Object.keys(variables).find(key => !variables[key].isGiven);

      // Relativistic velocity addition formula: v = (v1 + v2) / (1 + v1*v2/c¬≤)
      // Since we're working in units of c, c = 1, so: v = (v1 + v2) / (1 + v1*v2)
      
      switch (unknownVar) {
        case 'vTotal':
          // Given v1 and v2, find vTotal
          if (Math.abs(values.v1) >= 1 || Math.abs(values.v2) >= 1) {
            throw new Error('Individual velocities cannot be at or above the speed of light');
          }
          solution.vTotal = (values.v1 + values.v2) / (1 + values.v1 * values.v2);
          break;

        case 'v1':
          // Given v2 and vTotal, find v1
          // Rearranging: v1 = (vTotal - v2) / (1 - vTotal*v2)
          if (Math.abs(values.v2) >= 1 || Math.abs(values.vTotal) >= 1) {
            throw new Error('Velocities cannot be at or above the speed of light');
          }
          const denominator1 = 1 - values.vTotal * values.v2;
          if (Math.abs(denominator1) < 1e-10) {
            throw new Error('No valid solution: denominator approaches zero');
          }
          solution.v1 = (values.vTotal - values.v2) / denominator1;
          break;

        case 'v2':
          // Given v1 and vTotal, find v2
          // Rearranging: v2 = (vTotal - v1) / (1 - vTotal*v1)
          if (Math.abs(values.v1) >= 1 || Math.abs(values.vTotal) >= 1) {
            throw new Error('Velocities cannot be at or above the speed of light');
          }
          const denominator2 = 1 - values.vTotal * values.v1;
          if (Math.abs(denominator2) < 1e-10) {
            throw new Error('No valid solution: denominator approaches zero');
          }
          solution.v2 = (values.vTotal - values.v1) / denominator2;
          break;

        default:
          throw new Error('Unknown variable to solve for');
      }

      // Check if solution is physically valid
      Object.keys(solution).forEach(key => {
        if (Math.abs(solution[key]) >= 1) {
          throw new Error(`Calculated ${key.replace('v', 'velocity ')} exceeds the speed of light`);
        }
      });

      // Convert results back to display units and update input boxes
      const displayResults = {};
      const updatedVariables = { ...variables };
      
      Object.keys(solution).forEach(key => {
        const variable = variables[key];
        const convertedValue = convertFromBaseUnits(solution[key], variable.unit);
        
        displayResults[key] = {
          value: convertedValue,
          unit: variable.unit
        };
        
        // Update the input box with the calculated value
        updatedVariables[key] = {
          ...updatedVariables[key],
          value: convertedValue.toFixed(6).replace(/\.?0+$/, '') // Remove trailing zeros
        };
      });

      setVariables(updatedVariables);
      setResults(displayResults);
      setError('');

    } catch (err) {
      setError(err.message);
      setResults(null);
    }
  };

  const toggleGiven = (key) => {
    const currentGiven = Object.keys(variables).filter(k => variables[k].isGiven);
    
    if (variables[key].isGiven) {
      // Removing a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: false }
      }));
    } else if (currentGiven.length < 2) {
      // Adding a given variable
      setVariables(prev => ({
        ...prev,
        [key]: { ...prev[key], isGiven: true }
      }));
    }
  };

  const updateValue = (key, value) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], value }
    }));
  };

  const updateUnit = (key, unit) => {
    setVariables(prev => ({
      ...prev,
      [key]: { ...prev[key], unit }
    }));
  };

  const reset = () => {
    setVariables({
      v1: { value: '', unit: 'percent_c', isGiven: false },
      v2: { value: '', unit: 'percent_c', isGiven: false },
      vTotal: { value: '', unit: 'percent_c', isGiven: false }
    });
    setResults(null);
    setError('');
  };

  const variableLabels = {
    v1: 'Velocity v‚ÇÅ (First Object)',
    v2: 'Velocity v‚ÇÇ (Second Object, relative to first)',
    vTotal: 'Total Velocity (Second object relative to reference frame)'
  };

  const variableIcons = {
    v1: <Rocket className="w-4 h-4" />,
    v2: <Zap className="w-4 h-4" />,
    vTotal: <Users className="w-4 h-4" />
  };

  const givenCount = Object.keys(variables).filter(key => variables[key].isGiven).length;

  return (
    <div>
      <div className="bg-blue-50 border-l-4 border-blue-400 p-4 mb-6">
        <div className="flex items-start">
          <Info className="w-5 h-5 text-blue-400 mt-0.5 mr-2" />
          <div>
            <h3 className="text-sm font-medium text-blue-800">How it works:</h3>
            <p className="text-sm text-blue-700 mt-1">
              Select exactly 2 variables as "given" (known) and the calculator will solve for the remaining unknown using the relativistic velocity addition formula.
            </p>
            <p className="text-sm text-blue-700 mt-1">
              <strong>Example:</strong> Spaceship approaches asteroid at 0.60c, launches rocket forward at 0.30c relative to spaceship. What's the rocket's speed relative to asteroid?
            </p>
          </div>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {Object.keys(variables).map(key => (
          <div key={key} className="bg-gray-50 rounded-lg p-4 border">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                {variableIcons[key]}
                {variableLabels[key]}
              </label>
              <button
                onClick={() => toggleGiven(key)}
                disabled={!variables[key].isGiven && givenCount >= 2}
                className={`px-3 py-1 rounded text-xs font-medium transition-colors ${
                  variables[key].isGiven
                    ? 'bg-green-100 text-green-800 border border-green-300'
                    : givenCount >= 2
                    ? 'bg-gray-100 text-gray-400 border border-gray-200 cursor-not-allowed'
                    : 'bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200'
                }`}
              >
                {variables[key].isGiven ? 'Given' : 'Unknown'}
              </button>
            </div>
            
            <div className="flex gap-2">
              <div className="relative flex-1">
                <input
                  type="number"
                  value={variables[key].value}
                  onChange={(e) => updateValue(key, e.target.value)}
                  disabled={!variables[key].isGiven}
                  step="any"
                  className={`w-full px-3 py-2 border rounded-md text-sm ${
                    variables[key].isGiven
                      ? 'border-gray-300 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white'
                      : variables[key].value
                      ? 'border-green-300 bg-green-50 text-green-700 font-medium'
                      : 'border-gray-200 bg-gray-100 text-gray-500'
                  }`}
                  placeholder={variables[key].isGiven ? "Enter value" : variables[key].value ? "Calculated" : "Will be calculated"}
                />
                {!variables[key].isGiven && variables[key].value && (
                  <div className="absolute -top-1 -right-1 bg-green-500 text-white text-xs px-1.5 py-0.5 rounded-full font-medium">
                    ‚úì
                  </div>
                )}
              </div>
              <select
                value={variables[key].unit}
                onChange={(e) => updateUnit(key, e.target.value)}
                className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
              >
                {unitOptions.velocity.map(option => (
                  <option key={option.value} value={option.value}>
                    {option.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={solvePhysics}
          disabled={givenCount !== 2}
          className={`flex-1 py-3 px-6 rounded-lg font-medium transition-colors ${
            givenCount === 2
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          Calculate Velocity Addition
        </button>
        <button
          onClick={reset}
          className="px-6 py-3 border border-gray-300 rounded-lg font-medium text-gray-700 hover:bg-gray-50 transition-colors"
        >
          Reset
        </button>
      </div>

      <div className="text-center text-sm text-gray-600 mb-4">
        Selected: {givenCount}/2 variables
      </div>

      {error && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
          <p className="text-red-700 text-sm">{error}</p>
        </div>
      )}

      {results && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-4">
          <h3 className="text-sm font-semibold text-green-800 mb-2">‚úì Solution Complete</h3>
          <p className="text-sm text-green-700">
            Calculated unknown variable: {' '}
            {Object.keys(results).map(key => variableLabels[key]).join(', ')}
          </p>
        </div>
      )}

      <div className="mt-8 text-xs text-gray-500 bg-gray-50 p-4 rounded">
        <h4 className="font-medium mb-2">Physics Note:</h4>
        <p>
          This calculator uses the relativistic velocity addition formula: v = (v‚ÇÅ + v‚ÇÇ) / (1 + v‚ÇÅv‚ÇÇ/c¬≤). 
          Unlike classical mechanics where velocities simply add, relativistic velocities combine in a way that never exceeds the speed of light.
          Note that v‚ÇÇ is the velocity of the second object relative to the first object, while v‚ÇÅ is the velocity of the first object relative to the reference frame.
        </p>
      </div>
    </div>
  );
};

        // Render the main component
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(SpecialRelativityCalculators));
    </script>
</body>
</html>